! DART software - Copyright UCAR. This open source software is provided
! by UCAR, "as is", without charge, subject to all terms of use at
! http://www.image.ucar.edu/DAReS/DART/DART_download

!----------------------------------------------------------------------
! WARNING!!  The file obs_def_mod.f90 is AUTOGENERATED by the
! 'preprocess' program.  Any changes made to this file will be
! overwritten when it is regenerated.  To make permanent changes
! in the code, edit DEFAULT_obs_def_mod.F90, or edit the
! observation specific obs_def_xxx_mod.f90 files.
!----------------------------------------------------------------------

!----------------------------------------------------------------------
!----------------------------------------------------------------------
! Any observation-specific modules which contain executable code to
! handle the interpolation and/or reading and writing of the obs will
! have the module code inserted here.  Then models only have to use
! the obs_def_mod module, and only include obs_def_mod.f90 in their
! path_names files.  To change the observation types/kinds, edit the
! model-specific 'input.nml' file and add or remove lines from the
! &preprocess_nml section, the 'input_files' list.
!
! Start of any user-defined executable module code
!----------------------------------------------------------------------

!---------------------------------------------------------------------------  
! Start of code inserted from ../../../observations/forward_operators/obs_def_land_mod.f90
!---------------------------------------------------------------------------  
                                                                              

module obs_def_land_mod

! This is the basic module for the forward (observation) operators commonly
! used with land models.

use            types_mod, only : r8, MISSING_R8

use         location_mod, only : location_type, &
                                 write_location

use        utilities_mod, only : error_handler, &
                                 E_ERR, E_MSG, &
                                 do_output, ascii_file_format

use      assim_model_mod, only : interpolate

use ensemble_manager_mod, only : ensemble_type

use         obs_kind_mod, only : QTY_RADIATION_VISIBLE_DOWN, &
                                 QTY_RADIATION_NEAR_IR_DOWN, &
                                 QTY_RADIATION_VISIBLE_UP, &
                                 QTY_RADIATION_NEAR_IR_UP, &
                                 QTY_LIVE_STEM_CARBON, &
                                 QTY_DEAD_STEM_CARBON, &
                                 QTY_LEAF_CARBON, &
                                 QTY_FRACTION_ABSORBED_PAR, &
                                 QTY_PAR_DIRECT, &
                                 QTY_PAR_DIFFUSE, &
                                 QTY_ABSORBED_PAR, &
                                 QTY_SOLAR_INDUCED_FLUORESCENCE,&
                                 QTY_STEM_CARBON

implicit none
private

public :: calculate_albedo, &
          calculate_biomass, &
          calculate_biomass_tem, &
          calculate_fpar, &
          calculate_sif, &
          set_SIF_wavelength, &
          read_SIF_wavelength, &
          write_SIF_wavelength, &
          interactive_SIF_wavelength

character(len=*), parameter :: source = 'obs_def_land_mod.f90'

logical :: module_initialized = .false.

character(len=512) :: string1, string2, string3

! This might be useful, but not enough to warrant a namelist ... yet
logical :: debug = .false.

! Bits and bobs for the solar-induced fluorescence metadata
integer :: max_num_sif_obs = 200000
integer :: sifkey = 0
integer, allocatable :: sif_wavelength(:)
character(len=*), parameter :: SIF_STRING = 'lambda'

!===============================================================================
contains
!===============================================================================


subroutine initialize_module()

if (module_initialized) return

module_initialized = .true.

allocate(sif_wavelength(max_num_sif_obs))

end subroutine initialize_module


!===============================================================================


subroutine calculate_albedo(state_handle, ens_size, location, obs_val, istatus)

type(ensemble_type), intent(in)  :: state_handle
integer,             intent(in)  :: ens_size
type(location_type), intent(in)  :: location
real(r8),            intent(out) :: obs_val(ens_size)
integer,             intent(out) :: istatus(ens_size)

real(r8) ::  visible_in(ens_size)
real(r8) :: visible_out(ens_size)
real(r8) ::      nir_in(ens_size)
real(r8) ::     nir_out(ens_size)
real(r8) ::       numer(ens_size)
real(r8) ::       denom(ens_size)

integer :: stat(ens_size,4)
integer :: imem

istatus = 1           ! 0 == success, anything else is a failure
obs_val = MISSING_R8

call error_handler(E_ERR,'calculate_albedo','routine untested - stopping.', source )

if ( .not. module_initialized ) call initialize_module()

! Intentionally try to compute all required components before failing.
! The desire is to inform about ALL failed components instead of failing
! one-by-one.

call interpolate(state_handle, ens_size, location, QTY_RADIATION_VISIBLE_DOWN, &
        visible_in,  stat(:,1))
call interpolate(state_handle, ens_size, location, QTY_RADIATION_NEAR_IR_DOWN, &
        nir_in,      stat(:,2))
call interpolate(state_handle, ens_size, location, QTY_RADIATION_VISIBLE_UP, &
        visible_out, stat(:,3))
call interpolate(state_handle, ens_size, location, QTY_RADIATION_NEAR_IR_UP, &
        nir_out,     stat(:,4))

if (any(stat /= 0)) then
   istatus = stat(:,1)*1000 + stat(:,2)*100 + stat(:,3)*10 + stat(:,4)
   return
endif

numer = visible_out + nir_out
denom = visible_in  + nir_in

if (any(denom <= tiny(0.0_r8))) then
   call write_location(42,location,fform='FORMATTED',charstring=string1)
   call error_handler(E_MSG,'calculate_albedo','no incoming radiation',text2=string1)
   return
endif

obs_val = numer / denom

istatus = 0   ! success

if (debug .and. do_output()) then
   do imem = 1,ens_size
      write(string1,*)'incoming (visible nir sum status) ', &
         visible_in(imem), nir_in(imem), denom(imem), stat(imem,1)*1000 + stat(imem,2)*100
      write(string2,*)'outgoing (visible nir sum status) ', &
         visible_out(imem), nir_out(imem), numer(imem), stat(imem,3)*10 + stat(imem,4)
      write(string3,*)'albedo ', obs_val(imem)
      call error_handler(E_MSG,'calculate_albedo:',string1,text2=string2,text3=string3)
   enddo
endif

end subroutine calculate_albedo


!===============================================================================


subroutine calculate_biomass(state_handle, ens_size, location, obs_val, istatus)

type(ensemble_type), intent(in)  :: state_handle
integer,             intent(in)  :: ens_size
type(location_type), intent(in)  :: location
real(r8),            intent(out) :: obs_val(ens_size)
integer,             intent(out) :: istatus(ens_size)

real(r8) ::      leaf_carbon(ens_size)
real(r8) :: live_stem_carbon(ens_size)
real(r8) :: dead_stem_carbon(ens_size)
integer  :: stat(ens_size,3)
integer  :: imem

istatus = 1           ! 0 == success, anything else is a failure
obs_val = MISSING_R8

if ( .not. module_initialized ) call initialize_module()

! Intentionally try to compute all required components before failing.
! The desire is to inform about ALL failed components instead of failing
! one-by-one.

call interpolate(state_handle, ens_size, location, QTY_LEAF_CARBON, &
                 leaf_carbon,      stat(:,1))
call interpolate(state_handle, ens_size, location, QTY_LIVE_STEM_CARBON, &
                 live_stem_carbon, stat(:,2))
call interpolate(state_handle, ens_size, location, QTY_DEAD_STEM_CARBON, &
                 dead_stem_carbon, stat(:,3))

if (any(stat /= 0)) then
   istatus = stat(:,1)*100 + stat(:,2)*10 + stat(:,3)
   return
endif

obs_val = leaf_carbon + live_stem_carbon + dead_stem_carbon

istatus = 0   ! success

if (debug .and. do_output()) then
   do imem = 1,ens_size
      write(string1,*)'biomass for ensemble member ', imem
      write(string2,*)'carbon: leaf,live_stem,dead_stem', &
         leaf_carbon(imem), live_stem_carbon(imem), dead_stem_carbon(imem)
      write(string3,*)'status: leaf,live_stem,dead_stem', stat(imem,:)
      call error_handler(E_MSG,'calculate_biomass:',string1,text2=string2,text3=string3)
   enddo
endif

end subroutine calculate_biomass


subroutine calculate_biomass_tem(state_handle, ens_size, location, obs_val, istatus)
!================================================================================
! This is a revised version for TEM model since the biomass definition
! is a little different from CLM
type(ensemble_type), intent(in)  :: state_handle
integer,             intent(in)  :: ens_size
type(location_type), intent(in)  :: location
real(r8),            intent(out) :: obs_val(ens_size)
integer,             intent(out) :: istatus(ens_size)

real(r8) ::      leaf_carbon(ens_size)
real(r8) ::      stem_carbon(ens_size)
integer  :: stat(ens_size,2)
integer  :: imem

istatus = 1           ! 0 == success, anything else is a failure
obs_val = MISSING_R8

if ( .not. module_initialized ) call initialize_module()

! Intentionally try to compute all required components before failing.
! The desire is to inform about ALL failed components instead of failing
! one-by-one.

call interpolate(state_handle, ens_size, location, QTY_LEAF_CARBON, &
                 leaf_carbon,      stat(:,1))
call interpolate(state_handle, ens_size, location, QTY_STEM_CARBON, &
                 stem_carbon, stat(:,2))

if (any(stat /= 0)) then
   istatus = stat(:,1)*100 + stat(:,2)*10
   return
endif

obs_val = leaf_carbon + stem_carbon  ! aboveground biomass

istatus = 0   ! success

if (debug .and. do_output()) then
   do imem = 1,ens_size
      write(string1,*)'biomass for ensemble member ', imem
      write(string2,*)'carbon: leaf, stem', leaf_carbon(imem), stem_carbon(imem)
      write(string3,*)'status: leaf,stem', stat(imem,:)
      call error_handler(E_MSG,'calculate_biomass_tem:',string1,text2=string2,text3=string3)
   enddo
endif

end subroutine calculate_biomass_tem


!===============================================================================
!> calculate the fraction of photosynthetically available radiation
!> The MODIS website https://modis.gsfc.nasa.gov/data/dataprod/mod15.php
!> states: 'FPAR is the fraction of photosynthetically active radiation
!>          (400-700 nm) absorbed by green vegetation.'


subroutine calculate_fpar(state_handle, ens_size, location, obs_val, istatus)

type(ensemble_type), intent(in)  :: state_handle
integer,             intent(in)  :: ens_size
type(location_type), intent(in)  :: location
real(r8),            intent(out) :: obs_val(ens_size)
integer,             intent(out) :: istatus(ens_size)

real(r8) :: diffuse(ens_size)
real(r8) :: active(ens_size)
real(r8) :: absorbed(ens_size)
integer  :: stat(ens_size,3)
integer  :: imem
real(r8) :: denom

istatus = 1           ! 0 == success, anything else is a failure
obs_val = MISSING_R8

if ( .not. module_initialized ) call initialize_module()

! If the model state has it directly, this is simple.
! If it does not, we try to calculate it from what is available and what is absorbed

call interpolate(state_handle, ens_size, location, QTY_FRACTION_ABSORBED_PAR, &
                 obs_val, istatus)

if (all(istatus == 0)) return

! Intentionally try to compute all required components before failing.
! This is the part that needs scientific direction ...

call interpolate(state_handle, ens_size, location, QTY_PAR_DIRECT,   &
                 active,   stat(:,1))
call interpolate(state_handle, ens_size, location, QTY_PAR_DIFFUSE,   &
                 diffuse,  stat(:,2))
call interpolate(state_handle, ens_size, location, QTY_ABSORBED_PAR, &
                 absorbed, stat(:,3))

if (any(stat /= 0)) then
   istatus = stat(:,1)*1000 + stat(:,2)*100 + stat(:,3)
   return
endif

do imem = 1,ens_size

   ! If any of them are missing it is cause for failure and an early return
   if (absorbed(imem) == MISSING_R8 .or.  &
         active(imem) == MISSING_R8 .or.  &
        diffuse(imem) == MISSING_R8 ) then
      write(string1,*)'member',imem,'absorbed',absorbed(imem),'status',istatus(imem)
      write(string2,*)'values: active, absorbed',active(imem),diffuse(imem)
      call error_handler(E_MSG,'calculate_fpar:MISSING',string1,text2=string2)
      istatus(imem) = imem
      return
   endif

   denom = active(imem) + diffuse(imem)

   if (absorbed(imem) < tiny(denom)) then
      obs_val(imem) = 0.0_r8
      istatus(imem) = 0
   elseif (denom <= tiny(denom)) then ! avoid dividing by zeroish
      write(string1,*)'member ',imem,' denom ',denom
      write(string2,*)'values: active, diffuse ',active(imem),diffuse(imem)
      call error_handler(E_MSG,'calculate_fpar:ZERO',string1,text2=string2)
      istatus(imem) = imem
   else
      obs_val(imem) = min(absorbed(imem) / denom, 1.0_r8)
      istatus(imem) = 0
   endif

enddo

if (debug .and. do_output()) then
   do imem = 1,ens_size
      write(string1,*)'member ',imem,' fpar ',obs_val(imem),' status ',istatus(imem)
      write(string2,*)'values: active, diffuse, absorbed ', &
                      active(imem), diffuse(imem), absorbed(imem)
      write(string3,*)'status: active, diffuse, absorbed ',stat(imem,:)
      call error_handler(E_MSG,'calculate_fpar:',string1,text2=string2,text3=string3)
   enddo
endif

end subroutine calculate_fpar


!-------------------------------------------------------------------------------


subroutine calculate_sif(state_handle, ens_size, location, obs_val, istatus)

type(ensemble_type), intent(in)  :: state_handle
integer,             intent(in)  :: ens_size
type(location_type), intent(in)  :: location
real(r8),            intent(out) :: obs_val(ens_size)
integer,             intent(out) :: istatus(ens_size)

if ( .not. module_initialized ) call initialize_module()

! If the model state has it directly, this is simple.
! If it does not ... nothing else to try at the moment

call interpolate(state_handle, ens_size, location, &
                 QTY_SOLAR_INDUCED_FLUORESCENCE, obs_val, istatus)

end subroutine calculate_sif


!-------------------------------------------------------------------------------
!> stuff the value into the local metadata array

function set_SIF_wavelength(lambda) result(key)

integer, intent(in) :: lambda
integer :: key

if ( .not. module_initialized ) call initialize_module

! update the index into the module array
sifkey = sifkey + 1

! check that it fits
if (sifkey > max_num_sif_obs) call double_metadata()

sif_wavelength(sifkey) = lambda
key = sifkey

end function set_SIF_wavelength


!-------------------------------------------------------------------------------
!> writes the metadata for SIF observations.

subroutine read_SIF_wavelength(key, obsID, ifile, fform)

integer,           intent(out)          :: key
integer,           intent(in)           :: obsID
integer,           intent(in)           :: ifile
character(len=*),  intent(in), optional :: fform

character(len=*), parameter :: routine = 'read_SIF_wavelength'

logical  :: is_asciifile
integer  :: lambda
character(len=6) :: header
integer :: ierr
character(len=512) :: msgstring

if ( .not. module_initialized ) call initialize_module

! create string for error reporting
write(msgstring,*)'observation # ',obsID

! given the index into the local metadata arrays - retrieve
! the metadata for this particular observation.

is_asciifile = ascii_file_format(fform)

if (is_asciifile) then
   read(ifile, *, iostat=ierr) header
   call check_iostat(ierr,routine,'header',msgstring)
   read(ifile, *, iostat=ierr) lambda
   call check_iostat(ierr,routine,'lambda',msgstring)
   read(ifile, *, iostat=ierr) key
   call check_iostat(ierr,routine,'key',msgstring)
else
   read(ifile   , iostat=ierr) header
   call check_iostat(ierr,routine,'header',msgstring)
   read(ifile   , iostat=ierr) lambda
   call check_iostat(ierr,routine,'lambda',msgstring)
   read(ifile   , iostat=ierr) key
   call check_iostat(ierr,routine,'key',msgstring)
endif

sifkey = sifkey + 1

! check that it fits
if (sifkey > max_num_sif_obs) call double_metadata()

sif_wavelength(sifkey) = lambda
key = sifkey

end subroutine read_SIF_wavelength

!-------------------------------------------------------------------------------
!> writes the metadata for SIF observations.

subroutine write_SIF_wavelength(key, ifile, fform)

integer,           intent(in)           :: key
integer,           intent(in)           :: ifile
character(len=*),  intent(in), optional :: fform

logical  :: is_asciifile
integer  :: lambda

if ( .not. module_initialized ) call initialize_module

! given the index into the local metadata arrays - retrieve
! the metadata for this particular observation.

lambda = sif_wavelength(key)

is_asciifile = ascii_file_format(fform)

if (is_asciifile) then
   write(ifile, *) trim(SIF_STRING)
   write(ifile, *) lambda
   write(ifile, *) key
else
   write(ifile   ) trim(SIF_STRING)
   write(ifile   ) lambda
   write(ifile   ) key
endif

end subroutine write_SIF_wavelength


!-------------------------------------------------------------------------------
!> interactively queries for metadata required for SIF observations.

subroutine interactive_SIF_wavelength(key)

integer, intent(out) :: key

character(len=*), parameter :: routine = 'interactive_SIF_wavelength'
integer  :: lambda

if ( .not. module_initialized ) call initialize_module

write(*,*) 'Input wavelength of SIF (nm)'
read(*,*)lambda

key = set_SIF_wavelength(lambda)

end subroutine interactive_SIF_wavelength


!-------------------------------------------------------------------------------
!> creates enough space for more SIF metadata

subroutine double_metadata()

integer, allocatable :: temp_array(:)
integer :: existing_length
integer :: new_length

existing_length = size(sif_wavelength)
new_length      = 2 * existing_length

write(string1,*)'increasing metadata length from ',existing_length, &
                ' to ',new_length
call error_handler(E_MSG,'double_metadata',string1,source)

allocate(temp_array(existing_length))

temp_array = sif_wavelength

deallocate(sif_wavelength)
allocate(  sif_wavelength(new_length))

sif_wavelength(1:existing_length) = temp_array

deallocate(temp_array)

max_num_sif_obs = new_length

end subroutine double_metadata


!-------------------------------------------------------------------------------
!> simple error handling routine

subroutine check_iostat(istat, routine, context, msgstring)

integer,          intent(in) :: istat
character(len=*), intent(in) :: routine
character(len=*), intent(in) :: context
character(len=*), intent(in) :: msgstring

if ( istat /= 0 ) then
   write(string1,*)'istat should be 0 but is ',istat,' for '//context
   call error_handler(E_ERR, routine, string1, source, text2=msgstring)
end if

end subroutine check_iostat



end module obs_def_land_mod

                                                                              
!---------------------------------------------------------------------------  
! End of code inserted from ../../../observations/forward_operators/obs_def_land_mod.f90
!---------------------------------------------------------------------------  
!---------------------------------------------------------------------------  
! Start of code inserted from ../../../observations/forward_operators/obs_def_tower_mod.f90
!---------------------------------------------------------------------------  
                                                                              

module obs_def_tower_mod

! This is the forward observation operator code for CLM for flux tower observations.
! The DART model state for CLM generally does not have all the pieces necessary
! to apply the forward observation operator directly, so this code gets what it
! needs from a CLM history file. These history files have become complicated now
! that CLM is trying to support unstructured grids. Sometimes the variables of
! interest are shaped NEP(time, lat, lon), sometimes NEP(time, lndgrid).
! 'single column' runs may appear as either lat=lon=1 or lndgrid=1
!
use        types_mod, only : r4, r8, digits12, MISSING_R8, PI

use     location_mod, only : location_type, get_location, get_dist, &
                             set_location, write_location, VERTISUNDEF

use time_manager_mod, only : time_type, get_date, set_date, print_date, print_time, &
                             get_time, set_time, operator(-), operator(/=)

use    utilities_mod, only : register_module, E_ERR, E_MSG, error_handler, &
                             check_namelist_read, find_namelist_in_file,   &
                             nmlfileunit, do_output, do_nml_file, do_nml_term, &
                             file_exist, is_longitude_between

use netcdf_utilities_mod, only : nc_check

use      assim_model_mod, only : interpolate

use ensemble_manager_mod, only : ensemble_type

use typesizes
use netcdf

implicit none
private

public :: get_scalar_from_history

! version controlled file description for error handling, do not edit
character(len=*), parameter :: source   = 'obs_def_tower_mod.f90'
character(len=*), parameter :: revision = ''
character(len=*), parameter :: revdate  = ''

logical            :: module_initialized = .false.
logical            :: unstructured = .false.
character(len=512) :: string1, string2, string3
integer            :: nlon, nlat, ntime, ens_size
type(time_type)    :: initialization_time

character(len=256), allocatable, dimension(:) :: fname
integer,            allocatable, dimension(:) :: ncid
real(r8),           allocatable, dimension(:) :: lon, lat, area
real(digits12),     allocatable, dimension(:) :: rtime

real(r8), parameter :: RAD2KM = 40030.0_r8/(2.0_r8 * PI) ! (mean radius of earth ~6371km)

! namelist items
character(len=256) :: casename = 'clm_dart'
logical            :: debug = .false.
integer            :: hist_nhtfrq = -24
! CLM variable hist_nhtfrq ... controls how often to write out the history files.
! Negative value means the output frequency is the absolute value (in hours).

namelist /obs_def_tower_nml/ casename, debug, hist_nhtfrq

contains

!----------------------------------------------------------------------
!----------------------------------------------------------------------
! Start of executable routines
!----------------------------------------------------------------------
!----------------------------------------------------------------------

subroutine initialize_module(model_time)
type(time_type), intent(in) :: model_time

! Called once to set values and allocate space, open all the CLM files
! that have the observations, etc.

integer :: iunit, io, i
integer :: varid
integer :: year, month, day, hour, minute, second, leftover
integer, allocatable, dimension(:) :: yyyymmdd,sssss
type(time_type) :: tower_time

! Prevent multiple calls from executing this code more than once.
if (module_initialized) then
   if (initialization_time /= model_time) then
      string1 = 'model time does not match initialization time'
      string2 = 'model time does not match initialization time'
      string3 = 'model time does not match initialization time'
      call error_handler(E_ERR, 'obs_def_tower.initialize_routine', string1, &
                     source, revision, revdate, text2=string2,text3=string3)
   endif
   return
else
   initialization_time = model_time
endif

module_initialized = .true.

! Log the version of this source file.
call register_module(source, revision, revdate)

! Read the namelist entry.
call find_namelist_in_file("input.nml", "obs_def_tower_nml", iunit)
read(iunit, nml = obs_def_tower_nml, iostat = io)
call check_namelist_read(iunit, io, "obs_def_tower_nml")

! Record the namelist values used for the run ...
if (do_nml_file()) write(nmlfileunit, nml=obs_def_tower_nml)
if (do_nml_term()) write(     *     , nml=obs_def_tower_nml)

! Need to know what day we are trying to assimilate.
! The CLM h1 files contain everything STARTING with the time in their filename.
! all output intervals from that run are simply appended to that file.
! Consequently, we need to know the filename from the START of the model advance
! that resulted in the current model state. To construct the filename, we need
! to know one of the namelist variables from CLM. We are mandating that this
! value gets passed to DART via the obs_def_tower_nml instead of reading
! the CESM namelist .... hist_nhtfrq must be a negative number in a DART
! application of CLM ... and the STOP_OPTION must be "HOURS".
!
!  | start of the model advance ... *.h1.* file starts getting written
!  |
!  X==X==X==X==X==X==X==X==X==X==X==[O] (CLM model advance)
!  |<------- hist_nhtfrq ------->|   |
!                                |   | END of the model advance
!                                |
!                                | END of the data in the *.h1.* file

second = abs(hist_nhtfrq)*60*60
tower_time = model_time - set_time(second,0)

call get_date(tower_time, year, month, day, hour, minute, second)
second = second + minute*60 + hour*3600

! Figure out how many files (i.e. ensemble size) and construct their names.
! The CLM h0 files are constructed such that the midnight that starts the
! day is IN the file. The last time in the file is 23:30 ...

! In a perfect model scenario (i.e. 1 instance) CESM constructs filenames
! without the instance counter in them. We check for that first. If it
! exists we know the filename and ensemble size.

100 format (A,'.clm2_',I4.4,'.h1.',I4.4,'-',I2.2,'-',I2.2,'-',I5.5,'.nc')
110 format (A,'.clm2'      ,'.h1.',I4.4,'-',I2.2,'-',I2.2,'-',I5.5,'.nc')

write(string1,110) trim(casename),year,month,day,second

if( file_exist(string1) ) then
   ! We know we are in a perfect model scenario
   ens_size = 1
   if (debug .and. do_output()) write(*,*)'Ensemble size is believed to be ',ens_size
   goto 200
endif

ens_size = 0
ENSEMBLESIZE : do i = 1,200

   write(string1,100) trim(casename),i,year,month,day,second

   if( file_exist(string1) ) then
      if(debug .and. do_output()) &
            write(*,*)'observation file "',trim(string1),'" exists.'
      ens_size = ens_size + 1
   else
      if(debug .and. do_output()) &
            write(*,*)'WARNING observation file "',trim(string1),'" does not exist.'
      exit ENSEMBLESIZE
   endif

enddo ENSEMBLESIZE

if (ens_size < 2) then

   write(string1,110) trim(casename),year,month,day,second
   write(string2,*)'cannot find files to use for observation operator.'
   write(string3,*)'trying files with names like "',trim(string1),'"'
   call error_handler(E_ERR, 'obs_def_tower.initialize_routine', string2, &
                  source, revision, revdate, text2=string3)

elseif (ens_size >= 200) then

   write(string2,*)'ensemble size (',ens_size,') is unnaturally large.'
   write(string3,*)'trying files with names like "',trim(string1),'"'
   call error_handler(E_ERR, 'obs_def_tower.initialize_routine', string2, &
                  source, revision, revdate, text2=string3)

else

   if (debug .and. do_output()) then
      write(string1,*)'Ensemble size is believed to be ',ens_size
      call error_handler(E_MSG, 'obs_def_tower.initialize_routine', string1, &
                  source, revision, revdate )
   endif

endif

200 continue

allocate(fname(ens_size),ncid(ens_size))
ncid = 0

ENSEMBLE : do i = 1,ens_size
   if (ens_size == 1) then
      write(fname(i),110) trim(casename),year,month,day,second
      call nc_check(nf90_open(trim(fname(i)), nf90_nowrite, ncid(i)), &
          'obs_def_tower.initialize_routine','open '//trim(fname(i)))
      exit ENSEMBLE
   else
      write(fname(i),100) trim(casename),i,year,month,day,second
      call nc_check(nf90_open(trim(fname(i)), nf90_nowrite, ncid(i)), &
          'obs_def_tower.initialize_routine','open '//trim(fname(i)))
   endif
enddo ENSEMBLE

i = 1

! FIXME All other files will be opened to make sure they have the same dimensions.

call GetDimensions(ncid(i), fname(i))  ! determines values for nlon, nlat, ntime

allocate(lon(nlon), lat(nlat), rtime(ntime), yyyymmdd(ntime), sssss(ntime))

call nc_check(nf90_inq_varid(ncid(i), 'lon',    varid), &
              'obs_def_tower.initialize_routine','inq_varid lon '//trim(fname(i)))
call nc_check(nf90_get_var(  ncid(i), varid,      lon), &
              'obs_def_tower.initialize_routine','get_var lon'//trim(fname(i)))

call nc_check(nf90_inq_varid(ncid(i), 'lat',    varid), &
              'obs_def_tower.initialize_routine','inq_varid lat '//trim(fname(i)))
call nc_check(nf90_get_var(  ncid(i), varid,      lat), &
              'obs_def_tower.initialize_routine','get_var lat'//trim(fname(i)))

call nc_check(nf90_inq_varid(ncid(i), 'mcdate', varid), &
              'obs_def_tower.initialize_routine','inq_varid mcdate '//trim(fname(i)))
call nc_check(nf90_get_var(  ncid(i), varid, yyyymmdd), &
              'obs_def_tower.initialize_routine','get_var yyyymmdd'//trim(fname(i)))

call nc_check(nf90_inq_varid(ncid(i), 'mcsec',  varid), &
              'obs_def_tower.initialize_routine','inq_varid mcsec '//trim(fname(i)))
call nc_check(nf90_get_var(  ncid(i), varid,    sssss), &
              'obs_def_tower.initialize_routine','get_var sssss'//trim(fname(i)))

if ( (nlon == 1) .and. (nlat ==1) ) then
   allocate(area(nlon))
   call nc_check(nf90_inq_varid(ncid(i), 'area', varid), &
        'obs_def_tower.initialize_routine','inq_varid area '//trim(fname(i)))
   call nc_check(nf90_get_var(ncid(i), varid, area), &
        'obs_def_tower.initialize_routine', 'get_var area'//trim(fname(i)))
   if (debug .and. do_output()) write(*,*)'obs_def_tower      area',area(nlon)
endif

! Convert time in file to a time compatible with the observation sequence file.
do i = 1,ntime

   year     = yyyymmdd(i)/10000
   leftover = yyyymmdd(i) - year*10000
   month    = leftover/100
   day      = leftover - month*100

   hour     = sssss(i)/3600
   leftover = sssss(i) - hour*3600
   minute   = leftover/60
   second   = leftover - minute*60

   tower_time = set_date(year, month, day, hour, minute, second)
   call get_time(tower_time, second, day)

   rtime(i) = real(day,digits12) + real(second,digits12)/86400.0_digits12

   if (debug .and. do_output()) then
      write(*,*)'timestep yyyymmdd sssss',i,yyyymmdd(i),sssss(i)
      call print_date(tower_time,'tower_mod date')
      call print_time(tower_time,'tower_mod time')
      write(*,*)'tower_mod time as a real ',rtime(i)
   endif

enddo

if (debug .and. do_output()) write(*,*)'obs_def_tower      lon',lon
if (debug .and. do_output()) write(*,*)'obs_def_tower      lat',lat

!>@todo FIXME check all other ensemble member history files to make sure metadata is the same.

deallocate(yyyymmdd, sssss)

end subroutine initialize_module


!======================================================================


subroutine GetDimensions(ncid, fname)

! Harvest information from the first observation file.
! The SingleColumMode files have
!        float lat(lndgrid) ;
!        float lon(lndgrid) ;
!        float area(lndgrid) ;
! while the 2D files have
!        float lat(lat) ;
!        float lon(lon) ;
!        float area(lat, lon) ;

integer,          intent(in) :: ncid
character(len=*), intent(in) :: fname

! integer, intent(out) :: nlon, nlat, ntime ... module variables

integer, dimension(NF90_MAX_VAR_DIMS) :: londimids, latdimids
integer :: lonvarid, lonndims
integer :: latvarid, latndims
integer :: dimid

call nc_check(nf90_inq_varid(ncid,  'lon', lonvarid), &
              'obs_def_tower.GetDimensions','inq_varid lon '//trim(fname))
call nc_check(nf90_inq_varid(ncid,  'lat', latvarid), &
              'obs_def_tower.GetDimensions','inq_varid lat '//trim(fname))

call nc_check(nf90_inquire_variable(ncid, lonvarid, ndims=lonndims, dimids=londimids),&
              'obs_def_tower.GetDimensions','inquire lon '//trim(fname))
call nc_check(nf90_inquire_variable(ncid, latvarid, ndims=latndims, dimids=latdimids),&
              'obs_def_tower.GetDimensions','inquire lat '//trim(fname))

if ( (lonndims /= 1) .or. (latndims /= 1) ) then
   write(string1,*) 'Require "lon" and "lat" variables to be 1D. They are ', &
                     lonndims, latndims
   call error_handler(E_ERR,'obs_def_tower.GetDimensions',string1,source,revision,revdate)
endif

call nc_check(nf90_inquire_dimension(ncid, londimids(1), len=nlon), &
              'obs_def_tower.GetDimensions','inquire_dimension lon '//trim(fname))
call nc_check(nf90_inquire_dimension(ncid, latdimids(1), len=nlat), &
              'obs_def_tower.GetDimensions','inquire_dimension lat '//trim(fname))

call nc_check(nf90_inq_dimid(ncid, 'time', dimid), &
              'obs_def_tower.GetDimensions','inq_dimid time '//trim(fname))
call nc_check(nf90_inquire_dimension(ncid, dimid, len=ntime), &
              'obs_def_tower.GetDimensions','inquire_dimension time '//trim(fname))

if ( nf90_inq_dimid(ncid, 'lndgrid', dimid) == NF90_NOERR) then
   unstructured = .true.
   if ((nlon /= 1) .or. (nlat /= 1)) then
      string1 = 'unstructured grids with more than a single gridcell are not supported.'
      call error_handler(E_ERR,'obs_def_tower.GetDimensions',string1,source,revision,revdate)
   endif
endif

end subroutine GetDimensions


!======================================================================

subroutine get_scalar_from_history(varstring, state_handle, ens_size, copy_indices, location, &
                                   obs_time, obs_val, istatus)

character(len=*),    intent(in)  :: varstring
type(ensemble_type), intent(in)  :: state_handle
integer,             intent(in)  :: ens_size
integer,             intent(in)  :: copy_indices(ens_size) ! global ens_indicies
type(location_type), intent(in)  :: location
type(time_type),     intent(in)  :: obs_time
real(r8),            intent(out) :: obs_val(ens_size)
integer,             intent(out) :: istatus(ens_size)

integer :: imem

! This initialize_module call is going to open all files on all tasks
! when doing a distributed forward operator.
if ( .not. module_initialized ) call initialize_module(state_handle%current_time)

if ( unstructured ) then
   do imem = 1, ens_size
      call get_scalar_from_2Dhistory(varstring, copy_indices(imem), location, obs_time, obs_val(imem), istatus(imem))
   enddo
else
   do imem = 1, ens_size
      call get_scalar_from_3Dhistory(varstring, copy_indices(imem), location, obs_time,obs_val(imem), istatus(imem))
   enddo
endif

end subroutine get_scalar_from_history


!======================================================================


subroutine get_scalar_from_3Dhistory(varstring, ens_index, location, obs_time, &
                                     obs_val, istatus)
! the routine must return values for:
! obs_val -- the computed forward operator value
! istatus -- return code: 0=ok, > 0 is error, < 0 reserved for system use
!
! The requirement is that the history file variable is a 3D variable shaped similarly:
!
! float NEP(time, lat, lon) ;
!          NEP:long_name = "net ecosystem production, blah, blah, blah" ;
!          NEP:units = "gC/m^2/s" ;
!          NEP:cell_methods = "time: mean" ;
!          NEP:_FillValue = 1.e+36f ;
!          NEP:missing_value = 1.e+36f ;

character(len=*),    intent(in)  :: varstring
integer,             intent(in)  :: ens_index
type(location_type), intent(in)  :: location
type(time_type),     intent(in)  :: obs_time
real(r8),            intent(out) :: obs_val
integer,             intent(out) :: istatus

integer,  dimension(NF90_MAX_VAR_DIMS) :: dimids
real(r8), dimension(3) :: loc
integer,  dimension(3) :: ncstart, nccount
integer,  dimension(1) :: loninds, latinds, timeinds
integer                :: gridloni, gridlatj, timei
integer                :: varid, xtype, ndims, natts, dimlen
integer                :: io1, io2, second, day
real(r8)               :: loc_lon, loc_lat, radius, distance
real(r4), dimension(1) :: hyperslab
real(r4)               :: spvalR4
real(r8)               :: scale_factor, add_offset
real(digits12)         :: otime
character(len=NF90_MAX_NAME+20)      :: strshort

type(location_type) :: gridloc

obs_val = MISSING_R8
istatus = 1

!----------------------------------------------------------------------
! if observation is outside region encompassed in the history file - fail
loc      = get_location(location) ! loc is in DEGREES
loc_lon  = loc(1)
loc_lat  = loc(2)

if ( (nlon==1) .and. (nlat==1) ) then

   ! Defining the region if running in an unstructured grid is tricky.
   ! Have lat, lon, and the area of the gridcell which we assume to be basically square.
   ! The square root of the area defines the length of the edge of the gridcell.
   ! Half the hypotenuse defines the radius of a circle. Any ob within
   ! that radius is close enough.

   gridloc   = set_location(lon(1),lat(1), 0.0_r8, VERTISUNDEF)
   distance  = get_dist(gridloc, location, no_vert = .TRUE.) * RAD2KM ! planet earth
   radius    = sqrt(2.0_r8 * area(1))/2.0_r8

   if (debug .and. do_output()) then
      write(string1,*)'    observation lon, lat is ',loc_lon, loc_lat
      write(string2,*)'gridcell    lon, lat is ',lon(1),lat(1)
      write(string3,*)'area,radius is ',area(1),radius,' distance ',distance
      call error_handler(E_MSG, 'obs_def_tower.get_scalar_from_3Dhistory', &
                 string1, source, revision, revdate, text2=string2, text3=string3)
   endif

   if ( distance > radius ) return

else
   if ( .not. is_longitude_between(loc_lon, lon(1), lon(nlon), doradians=.FALSE.)) return
   if ((loc_lat < lat(1)) .or. (loc_lat > lat(nlat))) return
endif

!----------------------------------------------------------------------
! Now that we know the observation operator is possible, continue ...

write(strshort,'(''ens_index '',i4,1x,A)')ens_index,trim(varstring)

if (ens_index > ens_size) then
   write(string1,*)'Known to have ',ens_size,'ensemble members for observation operator.'
   write(string2,*)'asking to use operator for ensemble member ',ens_index
   call error_handler(E_ERR, 'obs_def_tower.get_scalar_from_3Dhistory', &
              string1, source, revision, revdate, text2=string2)
endif

!----------------------------------------------------------------------
! bombproofing ... make sure the netcdf file is open.

call nc_check(nf90_inquire(ncid(ens_index)), &
              'obs_def_tower.get_scalar_from_3Dhistory', 'inquire '//trim(strshort))

! bombproofing ... make sure the variable is the shape and size we expect

call nc_check(nf90_inq_varid(ncid(ens_index), trim(varstring), varid), &
        'obs_def_tower.get_scalar_from_3Dhistory', 'inq_varid '//trim(strshort))
call nc_check(nf90_inquire_variable(ncid(ens_index), varid, xtype=xtype, ndims=ndims, &
        dimids=dimids, natts=natts), &
        'obs_def_tower.get_scalar_from_3Dhistory','inquire variable '//trim(strshort))

if (ndims /= 3) then
   write(string1,*)trim(varstring),' is supposed to have 3 dimensions, it has',ndims
   call error_handler(E_ERR, 'obs_def_tower.get_scalar_from_3Dhistory', &
              string1, source, revision, revdate)
endif

! If the variable is not a NF90_FLOAT, then the assumptions for processing
! the missing_value, _FillValue, etc., may not be correct.
if (xtype /= NF90_FLOAT) then
   write(string1,*)trim(varstring),' is supposed to be a 32 bit real. xtype = ', &
                   NF90_FLOAT,' it is ',xtype
   call error_handler(E_ERR, 'obs_def_tower.get_scalar_from_3Dhistory', &
              string1, source, revision, revdate)
endif

! Dimension 1 is longitude
call nc_check(nf90_inquire_dimension(ncid(ens_index), dimids(1), len=dimlen), &
        'obs_def_tower.get_scalar_from_3Dhistory', 'inquire_dimension 1 '//trim(strshort))
if (dimlen /= nlon) then
   write(string1,*)'LON has length',nlon,trim(varstring),' has ',dimlen,'longitudes.'
   call error_handler(E_ERR, 'obs_def_tower.get_scalar_from_3Dhistory', &
              string1, source, revision, revdate)
endif

! Dimension 2 is latitude
call nc_check(nf90_inquire_dimension(ncid(ens_index), dimids(2), len=dimlen), &
        'obs_def_tower.get_scalar_from_3Dhistory', 'inquire_dimension 2 '//trim(strshort))
if (dimlen /= nlat) then
   write(string1,*)'LAT has length',nlat,trim(varstring),' has ',dimlen,'latitudes.'
   call error_handler(E_ERR, 'obs_def_tower.get_scalar_from_3Dhistory', &
              string1, source, revision, revdate)
endif

! Dimension 3 is time
call nc_check(nf90_inquire_dimension(ncid(ens_index), dimids(3), len=dimlen), &
        'obs_def_tower.get_scalar_from_3Dhistory', 'inquire_dimension 3'//trim(strshort))
if (dimlen /= ntime) then
   write(string1,*)'TIME has length',ntime,trim(varstring),' has ',dimlen,'times.'
   call error_handler(E_ERR, 'obs_def_tower.get_scalar_from_3Dhistory', &
              string1, source, revision, revdate)
endif

!----------------------------------------------------------------------
! Find the grid cell and timestep of interest
! FIXME ... since the history file contents are for the previous 30m,
! perhaps the closest time is not the best approximation.
! Get the individual locations values

call get_time(obs_time, second, day)
otime    = real(day,digits12) + real(second,digits12)/86400.0_digits12

latinds  = minloc(abs(lat - loc_lat))   ! these return 'arrays' ...
loninds  = minloc(abs(lon - loc_lon))   ! these return 'arrays' ...
timeinds = minloc(abs(rtime - otime))   ! these return 'arrays' ...

gridlatj = latinds(1)
gridloni = loninds(1)
timei    = timeinds(1)

if (debug .and. do_output()) then
   write(*,*)'obs_def_tower.get_scalar_from_3Dhistory:targetlon, lon, lon index is ', &
                                           loc_lon,lon(gridloni),gridloni
   write(*,*)'obs_def_tower.get_scalar_from_3Dhistory:targetlat, lat, lat index is ', &
                                           loc_lat,lat(gridlatj),gridlatj
   write(*,*)'obs_def_tower.get_scalar_from_3Dhistory:  targetT,   T,   T index is ', &
                                           otime,rtime(timei),timei
endif

if ( abs(otime - rtime(timei)) > 30*60 ) then
   if (debug .and. do_output()) then
      write(*,*)'obs_def_tower.get_scalar_from_3Dhistory: no close time ... skipping observation'
      call print_time(obs_time,'obs_def_tower.get_scalar_from_3Dhistory:observation time')
      call print_date(obs_time,'obs_def_tower.get_scalar_from_3Dhistory:observation date')
   endif
   istatus = 2
   return
endif

!----------------------------------------------------------------------
! Grab exactly the scalar we want.

ncstart = (/ gridloni, gridlatj, timei /)
nccount = (/        1,        1,     1 /)

call nc_check(nf90_get_var(ncid(ens_index),varid,hyperslab,start=ncstart,count=nccount), &
     'obs_def_tower.get_scalar_from_3Dhistory', 'get_var')

obs_val = hyperslab(1)

!----------------------------------------------------------------------
! Apply any netCDF attributes ...

io1 = nf90_get_att(ncid(ens_index), varid, '_FillValue' , spvalR4)
if ((io1 == NF90_NOERR) .and. (hyperslab(1) == spvalR4)) obs_val = MISSING_R8

io2 = nf90_get_att(ncid(ens_index), varid, 'missing_value' , spvalR4)
if ((io2 == NF90_NOERR) .and. (hyperslab(1) == spvalR4)) obs_val = MISSING_R8

io1 = nf90_get_att(ncid(ens_index), varid, 'scale_factor', scale_factor)
io2 = nf90_get_att(ncid(ens_index), varid, 'add_offset'  , add_offset)

if ( (io1 == NF90_NOERR) .and. (io2 == NF90_NOERR) ) then
   if (obs_val /= MISSING_R8) obs_val = obs_val * scale_factor + add_offset
elseif (io1 == NF90_NOERR) then
   if (obs_val /= MISSING_R8) obs_val = obs_val * scale_factor
elseif (io2 == NF90_NOERR) then
   if (obs_val /= MISSING_R8) obs_val = obs_val + add_offset
endif

if (obs_val /= MISSING_R8) istatus = 0

end subroutine get_scalar_from_3Dhistory


!======================================================================


subroutine get_scalar_from_2Dhistory(varstring, ens_index, location, obs_time, &
                                     obs_val, istatus)
! the routine must return values for:
! obs_val -- the computed forward operator value
! istatus -- return code: 0=ok, > 0 is error, < 0 reserved for system use
!
! The requirement is that the history file variable is a 2D variable shaped similarly:
!
! float NEP(time, lndgrid) ;
!          NEP:long_name = "net ecosystem production, blah, blah, blah" ;
!          NEP:units = "gC/m^2/s" ;
!          NEP:cell_methods = "time: mean" ;
!          NEP:_FillValue = 1.e+36f ;
!          NEP:missing_value = 1.e+36f ;
!
! Just because it is 2D does not mean it is a single column,
! although single columns are all that is really supported right now.

character(len=*),    intent(in)  :: varstring
integer,             intent(in)  :: ens_index
type(location_type), intent(in)  :: location
type(time_type),     intent(in)  :: obs_time
real(r8),            intent(out) :: obs_val
integer,             intent(out) :: istatus

integer,  dimension(NF90_MAX_VAR_DIMS) :: dimids
real(r8), dimension(3) :: loc
integer,  dimension(2) :: ncstart, nccount
integer,  dimension(1) :: timeinds
integer                :: gridij, timei
integer                :: varid, xtype, ndims, natts, dimlen
integer                :: io1, io2, second, day
real(r8)               :: loc_lon, loc_lat, radius, distance
real(r4), dimension(1) :: hyperslab
real(r4)               :: spvalR4
real(r8)               :: scale_factor, add_offset
real(digits12)         :: otime
character(len=NF90_MAX_NAME+20)      :: strshort

type(location_type) :: gridloc

obs_val = MISSING_R8
istatus = 1

!----------------------------------------------------------------------
! if observation is outside region encompassed in the history file - fail
loc      = get_location(location) ! loc is in DEGREES
loc_lon  = loc(1)
loc_lat  = loc(2)

! Defining the region if running in an unstructured grid is tricky.
! We have lat, lon, and the area of the gridcell which we assume to be basically square.
! The square root of the area defines the length of the edge of the gridcell.
! Half the hypotenuse defines the radius of a circle. Any ob within
! that radius is close enough.

! TJH FIXME This does not work with unstructured grid.
! latinds  = minloc(abs(lat - loc_lat))   ! these return 'arrays' ...
! loninds  = minloc(abs(lon - loc_lon))   ! these return 'arrays' ...
! gridij = the closest location

! The "1" in the following reflect the fact that only a single gridcell
! is currently supported in the unstructured grid configuration.
! (see GetDimensions())

gridij   = 1
gridloc  = set_location(lon(gridij),lat(gridij), 0.0_r8, VERTISUNDEF)
distance = get_dist(gridloc, location, no_vert = .TRUE.) * RAD2KM
radius   = sqrt(2.0_r8 * area(gridij))/2.0_r8

if (debug .and. do_output()) then
   write(string1,*)'    observation lon, lat is ',loc_lon, loc_lat
   write(string2,*)'gridcell    lon, lat is ',lon(gridij),lat(gridij)
   write(string3,*)'area,radius is ',area(gridij),radius,' distance ',distance
   call error_handler(E_MSG, 'obs_def_tower.get_scalar_from_2Dhistory', &
              string1, source, revision, revdate, text2=string2, text3=string3)
endif

if ( distance > radius ) return

!----------------------------------------------------------------------
! Now that we know the observation operator is possible, continue ...

write(strshort,'(''ens_index '',i4,1x,A)')ens_index,trim(varstring)

if (ens_index > ens_size) then
   write(string1,*)'believed to have ',ens_size,'ensemble members for observation operator.'
   write(string2,*)'asking to use operator for ensemble member ',ens_index
   call error_handler(E_ERR, 'obs_def_tower.get_scalar_from_2Dhistory', &
              string1, source, revision, revdate, text2=string2)
endif

!----------------------------------------------------------------------
! bombproofing ... make sure the netcdf file is open.

call nc_check(nf90_inquire(ncid(ens_index)), &
              'obs_def_tower.get_scalar_from_2Dhistory', 'inquire '//trim(strshort))

! bombproofing ... make sure the variable is the shape and size we expect

call nc_check(nf90_inq_varid(ncid(ens_index), trim(varstring), varid), &
        'obs_def_tower.get_scalar_from_2Dhistory', 'inq_varid '//trim(strshort))
call nc_check(nf90_inquire_variable(ncid(ens_index), varid, xtype=xtype, ndims=ndims, &
        dimids=dimids, natts=natts), &
        'obs_def_tower.get_scalar_from_2Dhistory','inquire variable '//trim(strshort))

if (ndims /= 2) then
   write(string1,*)trim(varstring),' is supposed to have 2 dimensions, it has',ndims
   call error_handler(E_ERR, 'obs_def_tower.get_scalar_from_2Dhistory', &
              string1, source, revision, revdate)
endif

! If the variable is not a NF90_FLOAT, then the assumptions for processing
! the missing_value, _FillValue, etc., may not be correct.
if (xtype /= NF90_FLOAT) then
   write(string1,*)trim(varstring),' is supposed to be a 32 bit real. xtype = ', &
                   NF90_FLOAT,' it is ',xtype
   call error_handler(E_ERR, 'obs_def_tower.get_scalar_from_2Dhistory', &
              string1, source, revision, revdate)
endif

! Dimension 1 is spatial
call nc_check(nf90_inquire_dimension(ncid(ens_index), dimids(1), len=dimlen), &
        'obs_def_tower.get_scalar_from_2Dhistory', 'inquire_dimension 1 '//trim(strshort))
if (dimlen /= nlon) then
   write(string1,*)'LON has length',nlon,trim(varstring),' has ',dimlen,'longitudes.'
   call error_handler(E_ERR, 'obs_def_tower.get_scalar_from_2Dhistory', &
              string1, source, revision, revdate)
endif

! Dimension 2 is time
call nc_check(nf90_inquire_dimension(ncid(ens_index), dimids(2), len=dimlen), &
        'obs_def_tower.get_scalar_from_2Dhistory', 'inquire_dimension 2 '//trim(strshort))
if (dimlen /= ntime) then
   write(string1,*)'TIME has length',ntime,trim(varstring),' has ',dimlen,'times.'
   call error_handler(E_ERR, 'obs_def_tower.get_scalar_from_2Dhistory', &
              string1, source, revision, revdate)
endif

!----------------------------------------------------------------------
! Find the timestep of interest
! FIXME ... since the history file contents are for the previous 30m,
! perhaps the closest time is not the best approximation.

call get_time(obs_time, second, day)
otime    = real(day,digits12) + real(second,digits12)/86400.0_digits12
timeinds = minloc(abs(rtime - otime))   ! these return 'arrays' ...
timei    = timeinds(1)

if (debug .and. do_output()) then
   write(*,*)'obs_def_tower.get_scalar_from_2Dhistory:  targetT,   T,   T index is ', &
                                           otime,rtime(timei),timei
endif

if ( abs(otime - rtime(timei)) > 30*60 ) then
   if (debug .and. do_output()) then
      write(*,*)'obs_def_tower.get_scalar_from_2Dhistory: no close time ... skipping observation'
      call print_time(obs_time,'obs_def_tower.get_scalar_from_2Dhistory:observation time')
      call print_date(obs_time,'obs_def_tower.get_scalar_from_2Dhistory:observation date')
   endif
   istatus = 2
   return
endif

!----------------------------------------------------------------------
! Grab exactly the scalar we want.

ncstart = (/ gridij, timei /)
nccount = (/      1,     1 /)

call nc_check(nf90_get_var(ncid(ens_index),varid,hyperslab,start=ncstart,count=nccount), &
     'obs_def_tower.get_scalar_from_2Dhistory', 'get_var')

obs_val = hyperslab(1)

!----------------------------------------------------------------------
! Apply any netCDF attributes ...

io1 = nf90_get_att(ncid(ens_index), varid, '_FillValue' , spvalR4)
if ((io1 == NF90_NOERR) .and. (hyperslab(1) == spvalR4)) obs_val = MISSING_R8

io2 = nf90_get_att(ncid(ens_index), varid, 'missing_value' , spvalR4)
if ((io2 == NF90_NOERR) .and. (hyperslab(1) == spvalR4)) obs_val = MISSING_R8

io1 = nf90_get_att(ncid(ens_index), varid, 'scale_factor', scale_factor)
io2 = nf90_get_att(ncid(ens_index), varid, 'add_offset'  , add_offset)

if ( (io1 == NF90_NOERR) .and. (io2 == NF90_NOERR) ) then
   if (obs_val /= MISSING_R8) obs_val = obs_val * scale_factor + add_offset
elseif (io1 == NF90_NOERR) then
   if (obs_val /= MISSING_R8) obs_val = obs_val * scale_factor
elseif (io2 == NF90_NOERR) then
   if (obs_val /= MISSING_R8) obs_val = obs_val + add_offset
endif

if (obs_val /= MISSING_R8) istatus = 0

end subroutine get_scalar_from_2Dhistory


!======================================================================


subroutine test_block
! Defining the region if running in a single column is tricky.
! We have lat, lon, and the area of the gridcell which we assume to be basically square.
! The square root of the area defines the length of the edge of the gridcell which
! can then be interpreted as the diameter of a circle. Any observation within this
! distance is close enough.

real(r8) :: x1, x2, y1, y2, d1, d2, d3, d4, radius, distance
type(location_type) :: gridloc, testloc

gridloc  = set_location(0.0_r8, 0.0_r8, 0.0_r8, VERTISUNDEF)
testloc  = set_location(1.0_r8, 0.0_r8, 0.0_r8, VERTISUNDEF)
distance = get_dist(gridloc, testloc, no_vert = .TRUE.) * RAD2KM
write(*,*)'TJH DEBUG: 1 degree at the equator has distance ',distance,' km.'

x1 = 286.8750               ! gridcell longitude is 287.50
x2 = 288.1250
y1 = 42.40837669372559      ! gridcell latitude is 42.8795814514160
y2 = 43.35078620910645

! compute the distance along the top of the grid cell
gridloc = set_location(x1, y1, 0.0_r8, VERTISUNDEF)
testloc = set_location(x2, y1, 0.0_r8, VERTISUNDEF)
d1      = get_dist(gridloc, testloc, no_vert = .TRUE.) * RAD2KM
gridloc = set_location(x2, y2, 0.0_r8, VERTISUNDEF)
d2      = get_dist(gridloc, testloc, no_vert = .TRUE.) * RAD2KM
testloc = set_location(x1, y2, 0.0_r8, VERTISUNDEF)
d3      = get_dist(gridloc, testloc, no_vert = .TRUE.) * RAD2KM
gridloc = set_location(x1, y1, 0.0_r8, VERTISUNDEF)
d4      = get_dist(gridloc, testloc, no_vert = .TRUE.) * RAD2KM

write(*,*)
write(*,*)'lengths         are ',d1,d2,d3,d4
write(*,*)'rectangular area is ',((d1+d3)/2.0_r8)*((d2+d4)/2.0_r8)

d1 = sqrt(area(1))
d2 = sqrt(2.0_r8 * d1**2)
d3 = d2 / 2.0_r8
radius = sqrt(2.0_r8 * area(1))/2.0_r8
write(*,*)'length of one side of a square is x = sqrt(area) = ',d1
write(*,*)'diagonal is                sqrt(x**2 + x**2)     = ',d2
write(*,*)'radius   is                sqrt(x**2 + x**2)/2.0 = ',d3
write(*,*)'-or-                       sqrt(area + area)/2.0 = ',radius

write(*,*)'TJH DEBUG: Radius,area is ',distance,PI*distance**2, &
          ' gridcell area is ',area(1)

end subroutine test_block


!======================================================================


end module obs_def_tower_mod

                                                                              
!---------------------------------------------------------------------------  
! End of code inserted from ../../../observations/forward_operators/obs_def_tower_mod.f90
!---------------------------------------------------------------------------  

!----------------------------------------------------------------------
! End of any user-defined executable module code
!----------------------------------------------------------------------
!----------------------------------------------------------------------

!----------------------------------------------------------------------
!----------------------------------------------------------------------


!----------------------------------------------------------------------
!----------------------------------------------------------------------
! Start of main obs_def_mod module code
!----------------------------------------------------------------------


module obs_def_mod

! Contains the basic parts of a module for defining and evaluating observation
! definitions. Can evaluate identity observations as is. The DART preprocess
! program is used to add in extra observation kinds at the indicated spots in
! the code.

use             types_mod, only : r8, i8, missing_i, missing_r8, obstypelength
use         utilities_mod, only : register_module, error_handler, E_ERR, E_MSG, &
                                  ascii_file_format
use          location_mod, only : location_type, read_location, write_location, &
                                  interactive_location, set_location_missing, &
                                  operator(/=)
use      time_manager_mod, only : time_type, read_time, write_time, operator(/=), &
                                  set_time_missing, interactive_time, &
                                  set_time, print_time
use       assim_model_mod, only : get_state_meta_data, interpolate
use          obs_kind_mod, only : assimilate_this_type_of_obs, &
                                  evaluate_this_type_of_obs, &
                                  get_name_for_type_of_obs, &
                                  map_type_of_obs_table, &
                                  get_type_of_obs_from_menu, &
                                  use_ext_prior_this_type_of_obs
use  ensemble_manager_mod, only : ensemble_type
use obs_def_utilities_mod, only : track_status, set_debug_fwd_op

!----------------------------------------------------------------------
! This list is autogenerated by the 'preprocess' program.  To add types
! or kinds, edit the obs_def_xxx_mod.f90 files, and then add/remove them
! from the 'input_files' variable of the &preprocess_nml namelist
! in the model-specific work/input.nml file.
!
! Start of obs_def_xxx_mod specific types and kinds
!----------------------------------------------------------------------

!---------------------------------------------------------------------------  
                                                                              
use obs_kind_mod, only : SOIL_TEMPERATURE
use obs_kind_mod, only : LPRM_SOIL_MOISTURE
use obs_kind_mod, only : SMOS_A_SOIL_MOISTURE
use obs_kind_mod, only : SMOS_D_SOIL_MOISTURE
use obs_kind_mod, only : SMAP_A_SOIL_MOISTURE
use obs_kind_mod, only : SMAP_D_SOIL_MOISTURE
use obs_kind_mod, only : SSMI_A_SOIL_MOISTURE
use obs_kind_mod, only : SSMI_D_SOIL_MOISTURE
use obs_kind_mod, only : AMSRE_A_SOIL_MOISTURE_X
use obs_kind_mod, only : AMSRE_D_SOIL_MOISTURE_X
use obs_kind_mod, only : AMSRE_A_SOIL_MOISTURE_C
use obs_kind_mod, only : AMSRE_D_SOIL_MOISTURE_C
use obs_kind_mod, only : TRMM_SOIL_MOISTURE
use obs_kind_mod, only : WINDSAT_SOIL_MOISTURE_X
use obs_kind_mod, only : WINDSAT_SOIL_MOISTURE_C
use obs_kind_mod, only : WATER_TABLE_DEPTH
use obs_kind_mod, only : SOIL_MOISTURE
use obs_kind_mod, only : LAYER_LIQUID_WATER
use obs_kind_mod, only : LAYER_ICE
use obs_kind_mod, only : SNOW_THICKNESS
use obs_kind_mod, only : SNOW_WATER
use obs_kind_mod, only : MODIS_SNOWCOVER_FRAC
use obs_kind_mod, only : MODIS_LEAF_AREA_INDEX
use obs_kind_mod, only : GIMMS_LEAF_AREA_INDEX
use obs_kind_mod, only : SP_LEAF_AREA_INDEX
use obs_kind_mod, only : SOIL_MINERAL_NITROGEN
use obs_kind_mod, only : MODIS_FPAR
use obs_kind_mod, only : BIOMASS
use obs_kind_mod, only : LEAF_CARBON
use obs_kind_mod, only : LIVE_STEM_CARBON
use obs_kind_mod, only : DEAD_STEM_CARBON
use obs_kind_mod, only : LEAF_AREA_INDEX
use obs_kind_mod, only : LEAF_NITROGEN
use obs_kind_mod, only : TOWER_AIR_TEMPERATURE
use obs_kind_mod, only : TREE_RING_NPP_FLUX
use obs_kind_mod, only : TOWER_SOIL_TEMPERATURE
use obs_kind_mod, only : TOWER_U_WIND_COMPONENT
use obs_kind_mod, only : TOWER_V_WIND_COMPONENT
use obs_kind_mod, only : TOWER_GLOBAL_RADIATION
use obs_kind_mod, only : TOWER_NET_CARBON_FLUX
use obs_kind_mod, only : SURFACE_ALBEDO
use obs_kind_mod, only : OCO2_SIF
use obs_kind_mod, only : ECOSTRESS_ET
use obs_kind_mod, only : HARMONIZED_SIF
use obs_kind_mod, only : SOIL_RESPIRATION_FLUX
use obs_kind_mod, only : TOWER_ER_FLUX
use obs_kind_mod, only : TOWER_GPP_FLUX
use obs_kind_mod, only : TOWER_LATENT_HEAT_FLUX
use obs_kind_mod, only : TOWER_NETC_ECO_EXCHANGE
use obs_kind_mod, only : TOWER_SENSIBLE_HEAT_FLUX
                                                                              
use obs_kind_mod, only : QTY_STATE_VARIABLE
use obs_kind_mod, only : QTY_ABSORBED_PAR
use obs_kind_mod, only : QTY_AQUIFER_WATER
use obs_kind_mod, only : QTY_BIOMASS
use obs_kind_mod, only : QTY_BRIGHTNESS_TEMPERATURE
use obs_kind_mod, only : QTY_BUCKET_MULTIPLIER
use obs_kind_mod, only : QTY_CANOPY_HEIGHT
use obs_kind_mod, only : QTY_CANOPY_TEMPERATURE
use obs_kind_mod, only : QTY_CANOPY_WATER
use obs_kind_mod, only : QTY_CARBON
use obs_kind_mod, only : QTY_CLAY_FRACTION
use obs_kind_mod, only : QTY_DEAD_ROOT_CARBON
use obs_kind_mod, only : QTY_DEAD_ROOT_NITROGEN
use obs_kind_mod, only : QTY_DEAD_STEM_CARBON
use obs_kind_mod, only : QTY_DEAD_STEM_NITROGEN
use obs_kind_mod, only : QTY_DEEP_GROUNDWATER_LEVEL
use obs_kind_mod, only : QTY_ER_FLUX
use obs_kind_mod, only : QTY_FPAR
use obs_kind_mod, only : QTY_FPAR_DIFFUSE
use obs_kind_mod, only : QTY_FPAR_DIRECT
use obs_kind_mod, only : QTY_FPAR_SHADED_DIFFUSE
use obs_kind_mod, only : QTY_FPAR_SHADED_DIRECT
use obs_kind_mod, only : QTY_FPAR_SUNLIT_DIFFUSE
use obs_kind_mod, only : QTY_FPAR_SUNLIT_DIRECT
use obs_kind_mod, only : QTY_FPSN
use obs_kind_mod, only : QTY_FRACTION_ABSORBED_PAR
use obs_kind_mod, only : QTY_FRAC_PHOTO_AVAIL_RADIATION
use obs_kind_mod, only : QTY_FSIF
use obs_kind_mod, only : QTY_GEOPOTENTIAL_HEIGHT
use obs_kind_mod, only : QTY_GROSS_PRIMARY_PROD_FLUX
use obs_kind_mod, only : QTY_GROUND_HEAT_FLUX
use obs_kind_mod, only : QTY_ICE
use obs_kind_mod, only : QTY_LATENT_HEAT_FLUX
use obs_kind_mod, only : QTY_LEAF_AREA_INDEX
use obs_kind_mod, only : QTY_LEAF_CARBON
use obs_kind_mod, only : QTY_LEAF_NITROGEN
use obs_kind_mod, only : QTY_LIQUID_WATER
use obs_kind_mod, only : QTY_LIVE_ROOT_CARBON
use obs_kind_mod, only : QTY_LIVE_ROOT_NITROGEN
use obs_kind_mod, only : QTY_LIVE_STEM_CARBON
use obs_kind_mod, only : QTY_LIVE_STEM_NITROGEN
use obs_kind_mod, only : QTY_NET_CARBON_FLUX
use obs_kind_mod, only : QTY_NET_CARBON_PRODUCTION
use obs_kind_mod, only : QTY_NET_PRIMARY_PROD_FLUX
use obs_kind_mod, only : QTY_NEUTRON_INTENSITY
use obs_kind_mod, only : QTY_NITROGEN
use obs_kind_mod, only : QTY_PAR_DIFFUSE
use obs_kind_mod, only : QTY_PAR_DIRECT
use obs_kind_mod, only : QTY_PHOTO_AVAILABLE_RADIATION
use obs_kind_mod, only : QTY_RADIATION
use obs_kind_mod, only : QTY_RADIATION_NEAR_IR_DOWN
use obs_kind_mod, only : QTY_RADIATION_NEAR_IR_UP
use obs_kind_mod, only : QTY_RADIATION_VISIBLE_DOWN
use obs_kind_mod, only : QTY_RADIATION_VISIBLE_UP
use obs_kind_mod, only : QTY_ROOT_CARBON
use obs_kind_mod, only : QTY_ROOT_NITROGEN
use obs_kind_mod, only : QTY_RTM_PARAMETERS_N
use obs_kind_mod, only : QTY_RTM_PARAMETERS_P
use obs_kind_mod, only : QTY_RUNOFF_MULTIPLIER
use obs_kind_mod, only : QTY_SAND_FRACTION
use obs_kind_mod, only : QTY_SENSIBLE_HEAT_FLUX
use obs_kind_mod, only : QTY_SNOWCOVER_FRAC
use obs_kind_mod, only : QTY_SNOW_DEPTH
use obs_kind_mod, only : QTY_SNOW_GRAIN_SIZE
use obs_kind_mod, only : QTY_SNOW_MIXING_RATIO
use obs_kind_mod, only : QTY_SNOW_NUMBER_CONCENTR
use obs_kind_mod, only : QTY_SNOW_TEMPERATURE
use obs_kind_mod, only : QTY_SNOW_THICKNESS
use obs_kind_mod, only : QTY_SNOW_WATER
use obs_kind_mod, only : QTY_SOIL_CARBON
use obs_kind_mod, only : QTY_SOIL_ICE
use obs_kind_mod, only : QTY_SOIL_LIQUID_WATER
use obs_kind_mod, only : QTY_SOIL_MATRIC_POTENTIAL
use obs_kind_mod, only : QTY_SOIL_MINERAL_NITROGEN
use obs_kind_mod, only : QTY_SOIL_MOISTURE
use obs_kind_mod, only : QTY_SOIL_NITROGEN
use obs_kind_mod, only : QTY_SOIL_RESPIRATION_FLUX
use obs_kind_mod, only : QTY_SOIL_TEMPERATURE
use obs_kind_mod, only : QTY_SOLAR_INDUCED_FLUORESCENCE
use obs_kind_mod, only : QTY_STEM_AREA_INDEX
use obs_kind_mod, only : QTY_STEM_CARBON
use obs_kind_mod, only : QTY_STEM_NITROGEN
use obs_kind_mod, only : QTY_STREAM_FLOW
use obs_kind_mod, only : QTY_STREAM_HEIGHT
use obs_kind_mod, only : QTY_SURFACE_ALBEDO
use obs_kind_mod, only : QTY_SURFACE_EMISSIVITY
use obs_kind_mod, only : QTY_SURFACE_HEAD
use obs_kind_mod, only : QTY_SURFACE_PRESSURE
use obs_kind_mod, only : QTY_SURFACE_RUNOFF
use obs_kind_mod, only : QTY_SURFACE_TYPE
use obs_kind_mod, only : QTY_TEMPERATURE
use obs_kind_mod, only : QTY_TOTAL_WATER_STORAGE
use obs_kind_mod, only : QTY_UNCONFINED_WATER
use obs_kind_mod, only : QTY_UNDER_RUNOFF
use obs_kind_mod, only : QTY_U_WIND_COMPONENT
use obs_kind_mod, only : QTY_VEGETATED_AREA_FRACTION
use obs_kind_mod, only : QTY_VEGETATION_TEMPERATURE
use obs_kind_mod, only : QTY_V_WIND_COMPONENT
use obs_kind_mod, only : QTY_WATER_TABLE_DEPTH
                                                                              
!---------------------------------------------------------------------------  
                                                                              

!----------------------------------------------------------------------
! End of obs_def_xxx_mod specific types and kinds
!----------------------------------------------------------------------

!----------------------------------------------------------------------
! This section is autogenerated by the 'preprocess' program.
!
! Start of any obs_def_xxx_mod specific use statements
!----------------------------------------------------------------------

! If any observation types required specialized code, the module code
! will have been added above, and now a use statement will be generated
! here so the generic obs_def_mod has access to the code.

  use obs_def_land_mod, only : calculate_albedo, &
                               calculate_biomass, &
                               calculate_biomass_tem, &
                               calculate_fpar, &
                               calculate_sif, &
                               read_sif_wavelength, &
                               write_sif_wavelength, &
                               interactive_sif_wavelength
  use obs_def_tower_mod, only : get_scalar_from_history

!----------------------------------------------------------------------
! End of any obs_def_xxx_mod specific use statements
!----------------------------------------------------------------------


implicit none
private

interface assignment(=)
   module procedure copy_obs_def
end interface

interface operator(==)
   module procedure eq_obs_def
end interface

interface operator(/=)
   module procedure ne_obs_def
end interface

public :: init_obs_def,                             &
          get_obs_def_location,                     &
          get_obs_def_type_of_obs,                  &
          get_obs_def_time,                         &
          get_obs_def_error_variance,               &
          get_obs_def_key,                          &
          set_obs_def_location,                     &
          set_obs_def_type_of_obs,                  &
          set_obs_def_time,                         &
          set_obs_def_error_variance,               &
          set_obs_def_key,                          &
          read_obs_def,                             &
          write_obs_def,                            &
          interactive_obs_def,                      &
          obs_def_type,                             &
          get_expected_obs_from_def_distrib_state,  &
          set_obs_def_external_FO,                  &
          set_obs_def_write_external_FO,            &
          destroy_obs_def,                          &
          copy_obs_def,                             &
          assignment(=),                            &
          eq_obs_def,                               &
          operator(==),                             &
          ne_obs_def,                               &
          operator(/=),                             &
          print_obs_def


! version controlled file description for error handling, do not edit
character(len=*), parameter :: source   = 'DEFAULT_obs_def_mod.F90'
character(len=*), parameter :: revision = ''
character(len=*), parameter :: revdate  = ''

! FIXME: should write_external_FO be some kind of global instead of
! being per-obs?

type obs_def_type
! In revision, obs_kind module is responsible for taking care of
! identity obs kinds, too
   private
   type(location_type)   :: location   ! center of mass, so to speak
   integer               :: kind       ! actually type
   type(time_type)       :: time
   real(r8)              :: error_variance
   integer               :: key        ! Used by specialized observation types
   logical               :: write_external_FO = .false.
   logical               :: has_external_FO   = .false.
   real(r8), allocatable :: external_FO(:)
   integer               :: external_FO_key
   integer               :: ens_size
end type obs_def_type

logical, save :: module_initialized = .false.

! define a fixed integer code that specifies whether a record
! in a binary obs_sequence file is a precomputed FO rather than a time_type.
! This value cannot be construed as the number of 'days'.

integer, parameter :: EXTERNAL_PRIOR_CODE = -123

contains

!----------------------------------------------------------------------------

subroutine initialize_module

call register_module(source, revision, revdate)
module_initialized = .true.

! Note that there is no namelist for this module now that
! obs_kind has been revised

end subroutine initialize_module


!----------------------------------------------------------------------------

subroutine init_obs_def(obs_def, location, obkind, obtime, error_variance)
! Need to add additional component arguments as optionals as needed

! Constructor for an obs_def

type(obs_def_type), intent(out) :: obs_def
type(location_type), intent(in) :: location
integer,             intent(in) :: obkind
type(time_type),     intent(in) :: obtime
real(r8),            intent(in) :: error_variance

if ( .not. module_initialized ) call initialize_module

obs_def%location = location
obs_def%kind = obkind
obs_def%time = obtime
obs_def%error_variance = error_variance
! No key assigned for standard observation defs
obs_def%key = -1

end subroutine init_obs_def

!---------------------------------------------------------------------

subroutine copy_obs_def(obs_def1, obs_def2)

! Copy function to be overloaded with '='

type(obs_def_type), intent(out) :: obs_def1
type(obs_def_type), intent(in) :: obs_def2

if ( .not. module_initialized ) call initialize_module

obs_def1%location       = obs_def2%location
obs_def1%kind           = obs_def2%kind
obs_def1%time           = obs_def2%time
obs_def1%error_variance = obs_def2%error_variance
obs_def1%key            = obs_def2%key
!deallocate(obs_def1%platform_qc)
!allocate(obs_def1%platform_qc(size(obs_def2%platform_qc))
! Should this be pointer assignment or regular
!obs_def1%platform_qc >= or == obs_def2%platform_qc
!obs_def1%aperture = obs_def2%aperture

obs_def1%has_external_FO = obs_def2%has_external_FO
if ( obs_def1%has_external_FO ) then
   call set_obs_def_external_FO(obs_def1, obs_def1%has_external_FO, obs_def2%write_external_FO,  &
                                obs_def2%external_FO_key, obs_def2%ens_size, obs_def2%external_FO)
endif

end subroutine copy_obs_def

!---------------------------------------------------------------------

subroutine print_obs_def(obs_def)

type(obs_def_type), intent(in) :: obs_def

character(len=256) :: string

if ( .not. module_initialized ) call initialize_module

call write_location(0, obs_def%location, charstring=string)
call error_handler(E_MSG, '', 'location: '//trim(string))

write(string, *) obs_def%kind, ', ', trim(get_name_for_type_of_obs(obs_def%kind))
call error_handler(E_MSG, '', 'type: '//trim(string))

call print_time(obs_def%time, ' time: ')

write(string, *) obs_def%error_variance
call error_handler(E_MSG, '', 'error variance: '//trim(string))

write(string, *) obs_def%key
call error_handler(E_MSG, '', 'private key: '//trim(string))

end subroutine print_obs_def

!---------------------------------------------------------------------

function eq_obs_def(obs_def1, obs_def2)

! Compare function to be overloaded with '=='

type(obs_def_type), intent(in) :: obs_def1
type(obs_def_type), intent(in) :: obs_def2
logical :: eq_obs_def

if ( .not. module_initialized ) call initialize_module

eq_obs_def = .false.

if (obs_def1%location       /= obs_def2%location) return
if (obs_def1%kind           /= obs_def2%kind) return
if (obs_def1%time           /= obs_def2%time) return
if (obs_def1%error_variance /= obs_def2%error_variance) return

! FIXME: should this be tested as well?  it could be different
! for identical obs - it's the key target that needs testing
! and that's type dependent.  for now, avoid testing it.
!if (obs_def1%key            /= obs_def2%key) return

eq_obs_def = .true.

end function eq_obs_def

!----------------------------------------------------------------------------

function ne_obs_def(obs_def1, obs_def2)

! Compare function to be overloaded with '/='

type(obs_def_type), intent(in) :: obs_def1
type(obs_def_type), intent(in) :: obs_def2
logical :: ne_obs_def

ne_obs_def = .not. eq_obs_def(obs_def1, obs_def2)

end function ne_obs_def

!----------------------------------------------------------------------------

function get_obs_def_key(obs_def)

type(obs_def_type), intent(in) :: obs_def
integer                        :: get_obs_def_key

if ( .not. module_initialized ) call initialize_module

get_obs_def_key = obs_def%key

end function get_obs_def_key

!----------------------------------------------------------------------------

function get_obs_def_error_variance(obs_def)

type(obs_def_type), intent(in) :: obs_def
real(r8)                       :: get_obs_def_error_variance

if ( .not. module_initialized ) call initialize_module

get_obs_def_error_variance = obs_def%error_variance

end function get_obs_def_error_variance

!----------------------------------------------------------------------------

function get_obs_def_location(obs_def)

! Returns observation location.

type(location_type)            :: get_obs_def_location
type(obs_def_type), intent(in) :: obs_def

if ( .not. module_initialized ) call initialize_module

get_obs_def_location = obs_def%location

end function get_obs_def_location

!----------------------------------------------------------------------------

function get_obs_def_type_of_obs(obs_def)

! Returns observation kind

integer                        :: get_obs_def_type_of_obs
type(obs_def_type), intent(in) :: obs_def

if ( .not. module_initialized ) call initialize_module

get_obs_def_type_of_obs = obs_def%kind

end function get_obs_def_type_of_obs

!----------------------------------------------------------------------------

function get_obs_def_time(obs_def)

! Returns observation time

type(time_type)                :: get_obs_def_time
type(obs_def_type), intent(in) :: obs_def

if ( .not. module_initialized ) call initialize_module

get_obs_def_time = obs_def%time

end function get_obs_def_time

!----------------------------------------------------------------------------

subroutine set_obs_def_location(obs_def, location)

! Sets the location of an obs_def

type(obs_def_type), intent(inout) :: obs_def
type(location_type),   intent(in) :: location

if ( .not. module_initialized ) call initialize_module

obs_def%location = location

end subroutine set_obs_def_location

!----------------------------------------------------------------------------

subroutine set_obs_def_error_variance(obs_def, error_variance)

! Sets the error variance of an obs_def

type(obs_def_type), intent(inout) :: obs_def
real(r8), intent(in) :: error_variance

if ( .not. module_initialized ) call initialize_module

obs_def%error_variance = error_variance

end subroutine set_obs_def_error_variance

!----------------------------------------------------------------------------

subroutine set_obs_def_key(obs_def, key)

! Sets the key of an obs_def

type(obs_def_type), intent(inout) :: obs_def
integer,            intent(in)    :: key

if ( .not. module_initialized ) call initialize_module

obs_def%key = key

end subroutine set_obs_def_key

!----------------------------------------------------------------------------

subroutine set_obs_def_external_FO(obs_def, has_external_FO, write_external_FO, external_FO_key, &
                                    ens_size, external_FO_values)

! Sets whether an obs_def has an external prior associated with it

type(obs_def_type), intent(inout) :: obs_def
logical,            intent(in)    :: has_external_FO
logical,            intent(in)    :: write_external_FO
integer,            intent(in)    :: external_FO_key, ens_size
real(r8),           intent(in)    :: external_FO_values(ens_size)

if ( .not. module_initialized ) call initialize_module

if ( .not. allocated(obs_def%external_FO)) allocate(obs_def%external_FO(ens_size))

obs_def%has_external_FO   = has_external_FO
obs_def%write_external_FO = write_external_FO
obs_def%external_FO_key   = external_FO_key
obs_def%ens_size          = ens_size
obs_def%external_FO(1:ens_size)  = external_FO_values(1:ens_size)

end subroutine set_obs_def_external_FO

!----------------------------------------------------------------------------

subroutine set_obs_def_write_external_FO(obs_def, write_external_FO)

! Sets whether to write out the external FO values or not.
! Should be true for programs which create these obs in the first place,
! should also be true for programs like the obs_sequence_tool.  Should be
! false for filter.

type(obs_def_type), intent(inout) :: obs_def
logical,            intent(in)    :: write_external_FO

if ( .not. module_initialized ) call initialize_module

obs_def%write_external_FO = write_external_FO

end subroutine set_obs_def_write_external_FO

!----------------------------------------------------------------------------

subroutine set_obs_def_type_of_obs(obs_def, kind)

! Sets the kind of an obs_def

type(obs_def_type), intent(inout) :: obs_def
integer,               intent(in) :: kind

if ( .not. module_initialized ) call initialize_module

obs_def%kind = kind

end subroutine set_obs_def_type_of_obs

!----------------------------------------------------------------------------

subroutine set_obs_def_time(obs_def, time)

! Sets the time of an obs_def

type(obs_def_type), intent(inout) :: obs_def
type(time_type), intent(in) :: time

if ( .not. module_initialized ) call initialize_module

obs_def%time = time

end subroutine set_obs_def_time

!----------------------------------------------------------------------------

subroutine get_expected_obs_from_def_distrib_state(state_handle, ens_size, copy_indices, key, obs_def, obs_kind_ind, &
   state_time, isprior, assimilate_this_ob, evaluate_this_ob, expected_obs, istatus)

! Compute forward operator for a particular obs_def
type(ensemble_type), intent(in)  :: state_handle
integer,             intent(in)  :: ens_size
integer,             intent(in)  :: copy_indices(ens_size)
integer,             intent(in)  :: key
type(obs_def_type),  intent(in)  :: obs_def
integer,             intent(in)  :: obs_kind_ind
type(time_type),     intent(in)  :: state_time
logical,             intent(in)  :: isprior
integer,             intent(out) :: istatus(ens_size)
logical,             intent(out) :: assimilate_this_ob, evaluate_this_ob
real(r8),            intent(out) :: expected_obs(ens_size)


type(location_type) :: location
type(time_type)     :: obs_time
integer             :: obs_key
real(r8)            :: error_var
logical             :: use_precomputed_FO
integer             :: copy

character(len=512) :: string1, string2, string3

! Load up the assimilate and evaluate status for this observation kind
assimilate_this_ob = assimilate_this_type_of_obs(obs_kind_ind)
evaluate_this_ob = evaluate_this_type_of_obs(obs_kind_ind)
use_precomputed_FO = use_ext_prior_this_type_of_obs(obs_kind_ind)

! If not being assimilated or evaluated return with missing_r8 and istatus 0
if(assimilate_this_ob .or. evaluate_this_ob) then
   ! for speed, access directly instead of using accessor functions
   location  = obs_def%location
   obs_time  = obs_def%time
   obs_key   = obs_def%key
   error_var = obs_def%error_variance

   ! the decision process here is that if some external source computed
   ! the prior forward operator values then we can use them or not, but
   ! if we use them there is no way to compute a consistent posterior.
   ! so the posteriors are always marked as 'failed forward operator'.
   if (use_precomputed_FO) then
      if (obs_def%ens_size < ens_size) then
         write(string1,'(A,1x,I4,1x,A,1x,I4)')'The number of precomputed forward operators (', &
                      obs_def%ens_size, ') is smaller than the ensemble size of ', ens_size
         write(string2,*)'observation type '//trim(get_name_for_type_of_obs(obs_def%kind))
         write(string3,*)'precomputed value(1) ', obs_def%external_FO(1)
         call error_handler(E_ERR, 'get_expected_obs_from_def', string1, source, &
                    text2=string2, text3=string3)
      endif

      if (isprior) then
         if ( obs_def%has_external_FO ) then
            do copy = 1, ens_size
               expected_obs(copy) = obs_def%external_FO(copy_indices(copy))
            enddo
            istatus = 0
         else
            call error_handler(E_ERR, 'get_expected_obs_from_def', &
                  'Attempt to access an external FO that is not present in the observation information.', &
                   source, revision, revdate, text2='observation type '//trim(get_name_for_type_of_obs(obs_def%kind)))
         endif
      else ! posterior - missing value
         expected_obs(:) = missing_r8
         istatus = 1
      endif
   else
      ! Compute the forward operator.  In spite of the variable name,
      ! obs_kind_ind is in fact a 'type' index number.  use the function
      ! get_quantity_for_type_of_obs from the obs_kind_mod if you want to map
      ! from a specific type to a generic kind.  the third argument of
      ! a call to the 'interpolate()' function must be a kind index and
      ! not a type.  normally the preprocess program does this for you.
      select case(obs_kind_ind)

         ! arguments available to an obs_def forward operator code are:
         !   state_handle -- to access the state vector
         !   ens_size     -- the number of ensemble members to do at once (between 1 and ens_size)
         !   copy_indices -- the indicies the ensemble members (between 1 and ens_size)
         !   location     -- observation location
         !   obs_kind_ind -- the index of the observation specific type
         !   obs_time     -- the time of the observation
         !   error_var    -- the observation error variance
         !   isprior      -- true for prior eval; false for posterior
         !
         ! the routine must return values for:
         !   expected_obs -- the computed forward operator values for all ensemble members
         !   istatus -- return code: 0=ok, >0 is error, <0 reserved for system use
         !
         ! to call interpolate() directly, the arg list MUST BE:
         !  interpolate(state_handle, ens_size, location, QTY_xxx, expected_obs, istatus)
         !
         ! the preprocess program generates lines like this automatically,
         ! and this matches the interfaces in each model_mod.f90 file.
         !
         ! CASE statements and algorithms for specific observation kinds are
         ! inserted here by the DART preprocess program.

  case(SURFACE_ALBEDO)
     call calculate_albedo(state_handle, ens_size, location, expected_obs, istatus)
  case(BIOMASS)
     !call calculate_biomass(state_handle, ens_size, location, expected_obs, istatus)
     call calculate_biomass_tem(state_handle, ens_size, location, expected_obs, istatus)!CCC
  case(MODIS_FPAR)
     call calculate_fpar(state_handle, ens_size, location, expected_obs, istatus)
  case(HARMONIZED_SIF)
     call calculate_sif(state_handle, ens_size, location, expected_obs, istatus)
  case(TOWER_LATENT_HEAT_FLUX)
     call get_scalar_from_history('EFLX_LH_TOT_R', state_handle, ens_size, &
                    copy_indices, location, obs_time, expected_obs, istatus)
  case(TOWER_SENSIBLE_HEAT_FLUX)
     call get_scalar_from_history('FSH', state_handle, ens_size, &
                    copy_indices, location, obs_time, expected_obs, istatus)
  case(TOWER_NETC_ECO_EXCHANGE)
     call get_scalar_from_history('NEP', state_handle, ens_size, &
                    copy_indices, location, obs_time, expected_obs, istatus)
  case(TOWER_GPP_FLUX)
     call get_scalar_from_history('GPP', state_handle, ens_size, &
                    copy_indices, location, obs_time, expected_obs, istatus)
  case(TOWER_ER_FLUX)
     call get_scalar_from_history('ER', state_handle, ens_size, &
                    copy_indices, location, obs_time, expected_obs, istatus)
  case(SOIL_RESPIRATION_FLUX)
     call get_scalar_from_history('SR', state_handle, ens_size, &
                    copy_indices, location, obs_time, expected_obs, istatus)
      case(SOIL_TEMPERATURE)
         call interpolate(state_handle, ens_size, location, QTY_SOIL_TEMPERATURE, expected_obs, istatus)
      case(LPRM_SOIL_MOISTURE)
         call interpolate(state_handle, ens_size, location, QTY_SOIL_MOISTURE, expected_obs, istatus)
      case(SMOS_A_SOIL_MOISTURE)
         call interpolate(state_handle, ens_size, location, QTY_SOIL_MOISTURE, expected_obs, istatus)
      case(SMOS_D_SOIL_MOISTURE)
         call interpolate(state_handle, ens_size, location, QTY_SOIL_MOISTURE, expected_obs, istatus)
      case(SMAP_A_SOIL_MOISTURE)
         call interpolate(state_handle, ens_size, location, QTY_SOIL_MOISTURE, expected_obs, istatus)
      case(SMAP_D_SOIL_MOISTURE)
         call interpolate(state_handle, ens_size, location, QTY_SOIL_MOISTURE, expected_obs, istatus)
      case(SSMI_A_SOIL_MOISTURE)
         call interpolate(state_handle, ens_size, location, QTY_SOIL_MOISTURE, expected_obs, istatus)
      case(SSMI_D_SOIL_MOISTURE)
         call interpolate(state_handle, ens_size, location, QTY_SOIL_MOISTURE, expected_obs, istatus)
      case(AMSRE_A_SOIL_MOISTURE_X)
         call interpolate(state_handle, ens_size, location, QTY_SOIL_MOISTURE, expected_obs, istatus)
      case(AMSRE_D_SOIL_MOISTURE_X)
         call interpolate(state_handle, ens_size, location, QTY_SOIL_MOISTURE, expected_obs, istatus)
      case(AMSRE_A_SOIL_MOISTURE_C)
         call interpolate(state_handle, ens_size, location, QTY_SOIL_MOISTURE, expected_obs, istatus)
      case(AMSRE_D_SOIL_MOISTURE_C)
         call interpolate(state_handle, ens_size, location, QTY_SOIL_MOISTURE, expected_obs, istatus)
      case(TRMM_SOIL_MOISTURE)
         call interpolate(state_handle, ens_size, location, QTY_SOIL_MOISTURE, expected_obs, istatus)
      case(WINDSAT_SOIL_MOISTURE_X)
         call interpolate(state_handle, ens_size, location, QTY_SOIL_MOISTURE, expected_obs, istatus)
      case(WINDSAT_SOIL_MOISTURE_C)
         call interpolate(state_handle, ens_size, location, QTY_SOIL_MOISTURE, expected_obs, istatus)
      case(WATER_TABLE_DEPTH)
         call interpolate(state_handle, ens_size, location, QTY_WATER_TABLE_DEPTH, expected_obs, istatus)
      case(SOIL_MOISTURE)
         call interpolate(state_handle, ens_size, location, QTY_SOIL_MOISTURE, expected_obs, istatus)
      case(LAYER_LIQUID_WATER)
         call interpolate(state_handle, ens_size, location, QTY_SOIL_LIQUID_WATER, expected_obs, istatus)
      case(LAYER_ICE)
         call interpolate(state_handle, ens_size, location, QTY_SOIL_ICE, expected_obs, istatus)
      case(SNOW_THICKNESS)
         call interpolate(state_handle, ens_size, location, QTY_SNOW_THICKNESS, expected_obs, istatus)
      case(SNOW_WATER)
         call interpolate(state_handle, ens_size, location, QTY_SNOW_WATER, expected_obs, istatus)
      case(MODIS_SNOWCOVER_FRAC)
         call interpolate(state_handle, ens_size, location, QTY_SNOWCOVER_FRAC, expected_obs, istatus)
      case(MODIS_LEAF_AREA_INDEX)
         call interpolate(state_handle, ens_size, location, QTY_LEAF_AREA_INDEX, expected_obs, istatus)
      case(GIMMS_LEAF_AREA_INDEX)
         call interpolate(state_handle, ens_size, location, QTY_LEAF_AREA_INDEX, expected_obs, istatus)
      case(SP_LEAF_AREA_INDEX)
         call interpolate(state_handle, ens_size, location, QTY_LEAF_AREA_INDEX, expected_obs, istatus)
      case(SOIL_MINERAL_NITROGEN)
         call interpolate(state_handle, ens_size, location, QTY_SOIL_MINERAL_NITROGEN, expected_obs, istatus)
      case(LEAF_CARBON)
         call interpolate(state_handle, ens_size, location, QTY_LEAF_CARBON, expected_obs, istatus)
      case(LIVE_STEM_CARBON)
         call interpolate(state_handle, ens_size, location, QTY_LIVE_STEM_CARBON, expected_obs, istatus)
      case(DEAD_STEM_CARBON)
         call interpolate(state_handle, ens_size, location, QTY_DEAD_STEM_CARBON, expected_obs, istatus)
      case(LEAF_AREA_INDEX)
         call interpolate(state_handle, ens_size, location, QTY_LEAF_AREA_INDEX, expected_obs, istatus)
      case(LEAF_NITROGEN)
         call interpolate(state_handle, ens_size, location, QTY_LEAF_NITROGEN, expected_obs, istatus)
      case(TOWER_AIR_TEMPERATURE)
         call interpolate(state_handle, ens_size, location, QTY_TEMPERATURE, expected_obs, istatus)
      case(TREE_RING_NPP_FLUX)
         call interpolate(state_handle, ens_size, location, QTY_NET_PRIMARY_PROD_FLUX, expected_obs, istatus)
      case(TOWER_SOIL_TEMPERATURE)
         call interpolate(state_handle, ens_size, location, QTY_TEMPERATURE, expected_obs, istatus)
      case(TOWER_U_WIND_COMPONENT)
         call interpolate(state_handle, ens_size, location, QTY_U_WIND_COMPONENT, expected_obs, istatus)
      case(TOWER_V_WIND_COMPONENT)
         call interpolate(state_handle, ens_size, location, QTY_V_WIND_COMPONENT, expected_obs, istatus)
      case(TOWER_GLOBAL_RADIATION)
         call interpolate(state_handle, ens_size, location, QTY_RADIATION, expected_obs, istatus)
      case(TOWER_NET_CARBON_FLUX)
         call interpolate(state_handle, ens_size, location, QTY_NET_CARBON_FLUX, expected_obs, istatus)
      case(OCO2_SIF)
         call interpolate(state_handle, ens_size, location, QTY_SOLAR_INDUCED_FLUORESCENCE, expected_obs, istatus)
      case(ECOSTRESS_ET)
         call interpolate(state_handle, ens_size, location, QTY_LATENT_HEAT_FLUX, expected_obs, istatus)

         ! If the observation kind is not available, it is an error. The DART
         ! preprocess program should provide code for all available kinds.
         case DEFAULT
            call error_handler(E_ERR, 'get_expected_obs_from_def', &
               'Attempt to evaluate or assimilate undefined obs_kind type.', &
                source, revision, revdate)
      end select
   endif
else
   ! Not computing forward operator for this kind
   expected_obs(:) = missing_r8
   istatus = 0
endif

end subroutine get_expected_obs_from_def_distrib_state



  subroutine read_obs_def(ifile, obs_def, key, obs_val, fform)
!----------------------------------------------------------------------------
! subroutine read_obs_def(ifile, obs_def, key, obs_val, fform)
!
! ifile
! obs_def
! key
! obs_val    needed if you want to perform operations based on value
! fform
!
! Reads an obs_def from file which is just an integer unit number in the
! current preliminary implementation.

integer,                    intent(in)    :: ifile
type(obs_def_type),         intent(inout) :: obs_def
integer,                    intent(in)    :: key
real(r8),                   intent(inout) :: obs_val
character(len=*), optional, intent(in)    :: fform

character(len=5)   :: header
integer            :: o_index
logical            :: is_ascii
character(len=32)  :: fileformat   ! here for backwards compatibility only
character(len=512) :: errstring
character(len=11)  :: header_external_FO
integer            :: ii, secs,days
character(len=128) :: string
logical            :: time_set
integer, save      :: counter = 0

if ( .not. module_initialized ) call initialize_module

is_ascii = ascii_file_format(fform)

! here for backwards compatibility only; after the next release,
! remove this and force people in their own obs_def_xxx_mod.f90 code
! to set the last arg to read/write to be fform instead of fileformat
if (is_ascii) then
   fileformat = 'formatted'
else
   fileformat = 'unformatted'
endif

! Begin by reading five character ascii header, then location, kind, error variance, index

! Need to add additional error checks on read
if (is_ascii) then
   read(ifile, '(a5)') header
   if(header /= 'obdef') then
      write(errstring, *) 'read "//header//" instead'
      call error_handler(E_ERR,'read_obs_def', &
         'Expected header "obdef" in input file', &
          source, revision, revdate, text2=errstring)
   endif
endif

! Read the location, kind, time and error variance
obs_def%location = read_location(ifile, fform)
if (is_ascii) then
   read(ifile, '(a5)' ) header
   if(header /= 'kind ') then
      write(errstring, *) 'read "//header//" instead'
      call error_handler(E_ERR,'read_kind', &
         'Expected kind header "kind " in input file', &
          source, revision, revdate, text2=errstring)
   endif
   read(ifile, *) o_index
else
   read(ifile)    o_index
endif

! Negative value is identity obs, doesn't need mapped
! Positive value must use mapping to get to proper index in obs_kind
if(o_index < 0) then
   obs_def%kind = o_index
else
   obs_def%kind = map_type_of_obs_table(o_index)
endif

! This kind may have its own module that needs to read more
select case(obs_def%kind)
   ! More complicated kinds may require reading additional information from
   ! an observation sequence file. Case code to do this is inserted here by
   ! the DART preprocess program.

    case(SURFACE_ALBEDO, &
         BIOMASS, &
         MODIS_FPAR)
       continue
    case(HARMONIZED_SIF)
       call read_SIF_wavelength(obs_def%key, key, ifile, fform)
    case(TOWER_LATENT_HEAT_FLUX, &
         TOWER_SENSIBLE_HEAT_FLUX, &
         TOWER_NETC_ECO_EXCHANGE, &
         TOWER_GPP_FLUX, &
         TOWER_ER_FLUX, &
         SOIL_RESPIRATION_FLUX)
       continue
   case(SOIL_TEMPERATURE)
      continue
   case(LPRM_SOIL_MOISTURE)
      continue
   case(SMOS_A_SOIL_MOISTURE)
      continue
   case(SMOS_D_SOIL_MOISTURE)
      continue
   case(SMAP_A_SOIL_MOISTURE)
      continue
   case(SMAP_D_SOIL_MOISTURE)
      continue
   case(SSMI_A_SOIL_MOISTURE)
      continue
   case(SSMI_D_SOIL_MOISTURE)
      continue
   case(AMSRE_A_SOIL_MOISTURE_X)
      continue
   case(AMSRE_D_SOIL_MOISTURE_X)
      continue
   case(AMSRE_A_SOIL_MOISTURE_C)
      continue
   case(AMSRE_D_SOIL_MOISTURE_C)
      continue
   case(TRMM_SOIL_MOISTURE)
      continue
   case(WINDSAT_SOIL_MOISTURE_X)
      continue
   case(WINDSAT_SOIL_MOISTURE_C)
      continue
   case(WATER_TABLE_DEPTH)
      continue
   case(SOIL_MOISTURE)
      continue
   case(LAYER_LIQUID_WATER)
      continue
   case(LAYER_ICE)
      continue
   case(SNOW_THICKNESS)
      continue
   case(SNOW_WATER)
      continue
   case(MODIS_SNOWCOVER_FRAC)
      continue
   case(MODIS_LEAF_AREA_INDEX)
      continue
   case(GIMMS_LEAF_AREA_INDEX)
      continue
   case(SP_LEAF_AREA_INDEX)
      continue
   case(SOIL_MINERAL_NITROGEN)
      continue
   case(LEAF_CARBON)
      continue
   case(LIVE_STEM_CARBON)
      continue
   case(DEAD_STEM_CARBON)
      continue
   case(LEAF_AREA_INDEX)
      continue
   case(LEAF_NITROGEN)
      continue
   case(TOWER_AIR_TEMPERATURE)
      continue
   case(TREE_RING_NPP_FLUX)
      continue
   case(TOWER_SOIL_TEMPERATURE)
      continue
   case(TOWER_U_WIND_COMPONENT)
      continue
   case(TOWER_V_WIND_COMPONENT)
      continue
   case(TOWER_GLOBAL_RADIATION)
      continue
   case(TOWER_NET_CARBON_FLUX)
      continue
   case(OCO2_SIF)
      continue
   case(ECOSTRESS_ET)
      continue

! A negative value means identity observations, just move along
   case (:-1)
      continue

   case DEFAULT
      write(errstring, *) 'unknown type number was ', obs_def%kind
      call error_handler(E_ERR, 'read_obs_def', &
         'Attempt to read for undefined obs_kind type.', &
         source, revision, revdate, text2=errstring)
end select

! We need to see whether there is external prior metadata.
! If so, we need to read it in, but that doesn't necessarily mean
! the precomputed FO will acutally be used for that particular obs_type

time_set = .false.
obs_def%write_external_FO = .false.  ! Always false when actually running DART

if (is_ascii) then
   read(ifile,fmt='(a)') string
   if (string(1:11) /= 'external_FO') then
      ! no metadata, we really just read the time record

      backspace(ifile) ! go back to previous line to prepare to read time
      obs_def%has_external_FO = .false.

   else
      ! we have a precomputed FO
      ! While we are happy to read in the obs_def%external_FO_key, the value
      ! is of no use outside the possiblity of being used in a debugging message.

      read(string, *) header_external_FO, obs_def%ens_size, obs_def%external_FO_key
      if ( .not. allocated(obs_def%external_FO)) allocate(obs_def%external_FO(obs_def%ens_size))
      read(ifile, *) (obs_def%external_FO(ii), ii=1,obs_def%ens_size)
      obs_def%has_external_FO = .true.

   endif
else
   ! Binary files do not have a character string identifier for precomputed
   ! forward observations.  The presence of external forward operator values
   ! is indicated by the value of the second item.

   read(ifile) secs, days
   if ( days /= EXTERNAL_PRIOR_CODE ) then ! we actually read the time
      obs_def%time = set_time(secs, days)
      time_set                = .true.
      obs_def%has_external_FO = .false.

   else
      ! we have a precomputed FO
      ! The obs_def%external_FO_key is set to a counter that may be useful in
      ! a debugging message, which would be more meaningful than the
      ! EXTERNAL_PRIOR_CODE value.
      counter                 = counter + 1
      obs_def%ens_size        = secs
      obs_def%external_FO_key = counter
      obs_def%has_external_FO = .true.
      if ( .not. allocated(obs_def%external_FO)) allocate(obs_def%external_FO(obs_def%ens_size))
      read(ifile) (obs_def%external_FO(ii), ii=1,obs_def%ens_size)
      !>@FIXME ... should this read (and the others) have status checks?
   endif
endif

! Read the time for the observation
if ( .not. time_set ) obs_def%time = read_time(ifile, fform)

if (is_ascii) then
   read(ifile, *) obs_def%error_variance
else
   read(ifile)    obs_def%error_variance
endif

end subroutine read_obs_def

!----------------------------------------------------------------------------

subroutine write_obs_def(ifile, obs_def, key, fform)

! Writes an obs_def to file.

integer,                    intent(in) :: ifile
type(obs_def_type),         intent(in) :: obs_def
integer,                    intent(in) :: key
character(len=*), intent(in), optional :: fform

logical           :: is_ascii
character(len=32) :: fileformat   ! here for backwards compatibility only

integer            :: ii ! CSS

if ( .not. module_initialized ) call initialize_module

is_ascii = ascii_file_format(fform)

! here for backwards compatibility only; after the next release,
! remove this and force people in their own obs_def_xxx_mod.f90 code
! to set the last arg to read/write to be fform instead of fileformat
if (is_ascii) then
   fileformat = 'formatted'
else
   fileformat = 'unformatted'
endif

! Write the 5 character identifier for verbose formatted output
if (is_ascii) write(ifile, '("obdef")')

! Write out the location, kind and error variance
call write_location(ifile, obs_def%location, fform)
if (is_ascii) then
   write(ifile, '("kind")' )
   write(ifile, *) obs_def%kind
else
   write(ifile)    obs_def%kind
endif

! This kind may have its own module that needs to write more
select case(obs_def%kind)
   ! More complicated kinds may require writing additional information from
   ! an observation sequence file. Case code to do this is inserted here by
   ! the DART preprocess program.

    case(SURFACE_ALBEDO, &
         BIOMASS, &
         MODIS_FPAR)
       continue
    case(HARMONIZED_SIF)
       call write_SIF_wavelength(key, ifile, fform)
    case(TOWER_LATENT_HEAT_FLUX, &
         TOWER_SENSIBLE_HEAT_FLUX, &
         TOWER_NETC_ECO_EXCHANGE, &
         TOWER_GPP_FLUX, &
         TOWER_ER_FLUX, &
         SOIL_RESPIRATION_FLUX)
       continue
   case(SOIL_TEMPERATURE)
      continue
   case(LPRM_SOIL_MOISTURE)
      continue
   case(SMOS_A_SOIL_MOISTURE)
      continue
   case(SMOS_D_SOIL_MOISTURE)
      continue
   case(SMAP_A_SOIL_MOISTURE)
      continue
   case(SMAP_D_SOIL_MOISTURE)
      continue
   case(SSMI_A_SOIL_MOISTURE)
      continue
   case(SSMI_D_SOIL_MOISTURE)
      continue
   case(AMSRE_A_SOIL_MOISTURE_X)
      continue
   case(AMSRE_D_SOIL_MOISTURE_X)
      continue
   case(AMSRE_A_SOIL_MOISTURE_C)
      continue
   case(AMSRE_D_SOIL_MOISTURE_C)
      continue
   case(TRMM_SOIL_MOISTURE)
      continue
   case(WINDSAT_SOIL_MOISTURE_X)
      continue
   case(WINDSAT_SOIL_MOISTURE_C)
      continue
   case(WATER_TABLE_DEPTH)
      continue
   case(SOIL_MOISTURE)
      continue
   case(LAYER_LIQUID_WATER)
      continue
   case(LAYER_ICE)
      continue
   case(SNOW_THICKNESS)
      continue
   case(SNOW_WATER)
      continue
   case(MODIS_SNOWCOVER_FRAC)
      continue
   case(MODIS_LEAF_AREA_INDEX)
      continue
   case(GIMMS_LEAF_AREA_INDEX)
      continue
   case(SP_LEAF_AREA_INDEX)
      continue
   case(SOIL_MINERAL_NITROGEN)
      continue
   case(LEAF_CARBON)
      continue
   case(LIVE_STEM_CARBON)
      continue
   case(DEAD_STEM_CARBON)
      continue
   case(LEAF_AREA_INDEX)
      continue
   case(LEAF_NITROGEN)
      continue
   case(TOWER_AIR_TEMPERATURE)
      continue
   case(TREE_RING_NPP_FLUX)
      continue
   case(TOWER_SOIL_TEMPERATURE)
      continue
   case(TOWER_U_WIND_COMPONENT)
      continue
   case(TOWER_V_WIND_COMPONENT)
      continue
   case(TOWER_GLOBAL_RADIATION)
      continue
   case(TOWER_NET_CARBON_FLUX)
      continue
   case(OCO2_SIF)
      continue
   case(ECOSTRESS_ET)
      continue

   ! A negative value means identity observations, just move along
   case (:-1)
      continue

   case DEFAULT
      call error_handler(E_ERR, 'write_obs_def', &
         'Attempt to write for undefined obs_kind type.', &
         source, revision, revdate)
end select

! obs_def%write_external_FO should only be true for program
! actually WRITING the external data.  When running DART
! obs_def%write_external_FO should be false and no metadata will be written
! Also want obs_def%write_external_FO to somehow be true when this called from
! the obs_sequence_tool program
if ( obs_def%has_external_FO .and. obs_def%write_external_FO ) then
   if ( .not. allocated(obs_def%external_FO)) then
      call error_handler(E_ERR, 'write_obs_def', &
         'obs_def%external_FO not allocated but writing was requested.', &
         source, revision, revdate, text2='observation type '//trim(get_name_for_type_of_obs(obs_def%kind)))
   endif
   if (is_ascii) then
      write(ifile, 12) obs_def%ens_size, key
      write(ifile, *) (obs_def%external_FO(ii), ii=1,obs_def%ens_size)
   else
      write(ifile)    obs_def%ens_size, EXTERNAL_PRIOR_CODE
      write(ifile)    (obs_def%external_FO(ii), ii=1,obs_def%ens_size)
   endif
12  format('external_FO', 2i8)
endif

call write_time(ifile, obs_def%time, fform)

if (is_ascii) then
   write(ifile, *) obs_def%error_variance
else
   write(ifile)    obs_def%error_variance
endif

end subroutine write_obs_def


subroutine interactive_obs_def(obs_def, key)
!---------------------------------------------------------------------------
!
! Allows interactive creation of an observation

type(obs_def_type), intent(inout) :: obs_def
integer,               intent(in) :: key

if ( .not. module_initialized ) call initialize_module

! Get the observation kind WANT A STRING OPTION, TOO?
obs_def%kind = get_type_of_obs_from_menu()

! Input any special stuff for this kind
select case(obs_def%kind)
   ! More complicated kinds may require inputting additional information to
   ! define an observation. Case code to do this is inserted here by the
   ! DART preprocess program.

    case(SURFACE_ALBEDO, &
         BIOMASS, &
         MODIS_FPAR)
       continue
    case(HARMONIZED_SIF)
       call interactive_SIF_wavelength(obs_def%key)
    case(TOWER_LATENT_HEAT_FLUX, &
         TOWER_SENSIBLE_HEAT_FLUX, &
         TOWER_NETC_ECO_EXCHANGE, &
         TOWER_GPP_FLUX, &
         TOWER_ER_FLUX, &
         SOIL_RESPIRATION_FLUX)
       continue
   case(SOIL_TEMPERATURE)
      continue
   case(LPRM_SOIL_MOISTURE)
      continue
   case(SMOS_A_SOIL_MOISTURE)
      continue
   case(SMOS_D_SOIL_MOISTURE)
      continue
   case(SMAP_A_SOIL_MOISTURE)
      continue
   case(SMAP_D_SOIL_MOISTURE)
      continue
   case(SSMI_A_SOIL_MOISTURE)
      continue
   case(SSMI_D_SOIL_MOISTURE)
      continue
   case(AMSRE_A_SOIL_MOISTURE_X)
      continue
   case(AMSRE_D_SOIL_MOISTURE_X)
      continue
   case(AMSRE_A_SOIL_MOISTURE_C)
      continue
   case(AMSRE_D_SOIL_MOISTURE_C)
      continue
   case(TRMM_SOIL_MOISTURE)
      continue
   case(WINDSAT_SOIL_MOISTURE_X)
      continue
   case(WINDSAT_SOIL_MOISTURE_C)
      continue
   case(WATER_TABLE_DEPTH)
      continue
   case(SOIL_MOISTURE)
      continue
   case(LAYER_LIQUID_WATER)
      continue
   case(LAYER_ICE)
      continue
   case(SNOW_THICKNESS)
      continue
   case(SNOW_WATER)
      continue
   case(MODIS_SNOWCOVER_FRAC)
      continue
   case(MODIS_LEAF_AREA_INDEX)
      continue
   case(GIMMS_LEAF_AREA_INDEX)
      continue
   case(SP_LEAF_AREA_INDEX)
      continue
   case(SOIL_MINERAL_NITROGEN)
      continue
   case(LEAF_CARBON)
      continue
   case(LIVE_STEM_CARBON)
      continue
   case(DEAD_STEM_CARBON)
      continue
   case(LEAF_AREA_INDEX)
      continue
   case(LEAF_NITROGEN)
      continue
   case(TOWER_AIR_TEMPERATURE)
      continue
   case(TREE_RING_NPP_FLUX)
      continue
   case(TOWER_SOIL_TEMPERATURE)
      continue
   case(TOWER_U_WIND_COMPONENT)
      continue
   case(TOWER_V_WIND_COMPONENT)
      continue
   case(TOWER_GLOBAL_RADIATION)
      continue
   case(TOWER_NET_CARBON_FLUX)
      continue
   case(OCO2_SIF)
      continue
   case(ECOSTRESS_ET)
      continue

   ! A negative value means identity observations, just move along
   case (:-1)
      continue
   case DEFAULT
      call error_handler(E_ERR, 'interactive_obs_def', &
         'Attempt to interactively create undefined obs_kind type.', &
         source, revision, revdate)
end select

! If the kind is an identity observation, don't need to call location
! Get location from state meta_data
if(obs_def%kind < 0) then
   ! Get the location of this from model
   call get_state_meta_data(-1_i8 * obs_def%kind, obs_def%location)
else! Get the location
   call interactive_location(obs_def%location)
endif

! Get the time
call interactive_time(obs_def%time)

write(*, *) 'Input the error variance for this observation definition '
read(*, *) obs_def%error_variance
do while (obs_def%error_variance < 0)
   write(*, *) 'The error variance must be positive, please try again'
   read(*, *) obs_def%error_variance
enddo

end subroutine interactive_obs_def

!----------------------------------------------------------------

subroutine destroy_obs_def(obs_def)
! TECHNICALLY NEED TO CALL DESTRUCTORS FOR ALL SUBCOMPONENTS,
! NO ALLOCATED STORAGE YET

type(obs_def_type), intent(inout) :: obs_def

real(r8) :: missing_r(1)


if ( .not. module_initialized ) call initialize_module

! FIXME: not clear why we have to set all these to missing...
! we definitely have to do the deallocate but the others seem
! like unnecessary work.

call set_obs_def_location(obs_def, set_location_missing() )
obs_def%kind = missing_i
call set_obs_def_time(obs_def, set_time_missing() )
call set_obs_def_error_variance( obs_def, missing_r8)
missing_r = missing_r8
call set_obs_def_external_FO(obs_def, .false., .false., missing_i, 1, missing_r)
if ( allocated(obs_def%external_FO)) deallocate(obs_def%external_FO) ! CSS

end subroutine destroy_obs_def



!---------------------------------------------------------------------------
!---------------------------------------------------------------------------

end module obs_def_mod

